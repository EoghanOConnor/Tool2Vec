{
  "numpy.absolute": {
    "new_func": "elemental_magnitude",
    "description": "Compute the non-negative magnitude of each element in the input array. For complex numbers, the Euclidean distance from the origin is returned. Parameters: - input_array (array_like): The array containing elements for which the magnitude is calculated. - output (array, optional): A location where the result is stored. - where (array_like, optional): Condition to decide where the operation is applied; otherwise, retains the original value. Returns: - magnitude_array (array): An array with the magnitude of each element from the input array."
  },
  "numpy.add": {
    "new_func": "elemental_summation",
    "description": "Perform an element-by-element addition of two arrays. Parameters: - addend1, addend2 (array_like): Arrays to be summed. They should be broadcastable to a common shape. - output (array, optional): A location to store the result. - where (array_like, optional): Condition to decide where the operation is applied; otherwise, retains the original value. Returns: - sum_result (array or scalar): The sum of the two input arrays, performed element-wise. This will be a scalar if both inputs are scalars."
  },
  "numpy.all": {
    "new_func": "uniform_truth_check",
    "description": "Check if all elements of the array are true, along a specified axis. Parameters: - test_array (array_like): The array to be tested. - axis (int or tuple of ints, optional): Axis or axes along which to perform the logical AND reduction. - output (array, optional): Alternate output array to place the result. - keepdims (bool, optional): If set to True, the reduced axes are left in the result as dimensions with size one. - where (array_like of bool, optional): Elements to include in the truth check. Returns: - unanimous_result (array, bool): A boolean indicating if all elements are true or an array of booleans if an axis is specified."
  },
  "numpy.amax": {
    "new_func": "peak_element",
    "description": "Identify the highest value in an array, or along a particular axis. Parameters: - candidate_array (array_like): The array from which to find the maximum value. - axis (int, optional): The axis along which to find the maximum. If None, the maximum of the flattened array is returned. - output (array, optional): Alternate output array to place the result. - keepdims (bool, optional): If set to True, the reduced axes are left in the result as dimensions with size one. - initial (scalar, optional): The minimum value of an output element. - where (array_like, optional): Locations at which to evaluate the maximum. Returns: - maximum_value (array): An array with the maximum values along the specified axis or the overall maximum value."
  },
  "numpy.acos": {
    "new_func": "inverse_cosine",
    "description": "Determine the angle in radians whose cosine is the specified value, computed element-wise. Parameters: - cosine_value (array_like): The value(s) whose arc cosine is to be computed. - output (array, optional): A location where the result is stored. - where (array_like, optional): Condition to decide where the operation is applied; otherwise, retains the original value. Returns: - angle_radians (array): The angles in radians, lying in the range [0, pi], corresponding to the arc cosine of the input values."
  },
  "numpy.acosh": {
    "new_func": "inverse_hypercosine",
    "description": "Calculates the inverse of the hyperbolic cosine for each element of the input array, working element-wise. Parameters: - input_array: array_like, The input values for which the inverse hyperbolic cosine is calculated. - out: array, None, or tuple of array and None, optional, A location into which the result is stored. If not provided, a new array is allocated. - where: array_like, optional, Condition over the input to decide where the inverse hyperbolic cosine is to be computed. - **kwargs: Additional keyword arguments for fine-tuning. Returns: - output_array: array, An array with the same shape as the input array containing the inverse hyperbolic cosine of each element."
  },
  "numpy.allclose": {
    "new_func": "nearly_identical",
    "description": "Determines whether two arrays are approximately equivalent by comparing their elements to within specified tolerances. Parameters: - first_array: array_like, First input array to compare. - second_array: array_like, Second input array to compare. - rtol: array_like, The relative tolerance parameter. - atol: array_like, The absolute tolerance parameter. - equal_nan: bool, Specifies whether to consider NaNs as equal. Returns: - is_approx_equal: bool, True if arrays are approximately the same within the tolerances, False otherwise."
  },
  "numpy.amin": {
    "new_func": "array_minimum",
    "description": "Identifies the smallest value in an array or along a specified axis. Parameters: - input_array: array_like, Array containing numbers whose minimum is to be found. - axis: None or int, Axis along which to operate. By default, flattened input is used. - out: array, Optional output array to store the result. - keepdims: bool, If set to True, the axes which are reduced are left in the result as dimensions with size one. - initial: scalar, The minimum value of an output element. Ignored if the input array is empty. - where: array_like, Elements to include in the reduction. Returns: - minimum_value: array or scalar, Minimum of input_array. If axis is None, the result is a scalar value. If axis is given, the result is an array of dimension array.ndim - 1."
  },
  "numpy.angle": {
    "new_func": "complex_argument",
    "description": "Calculates the angle in the complex plane for which the real and imaginary parts of the input represent the cosine and sine, respectively. Parameters: - complex_input: array_like, An array of complex numbers. - degrees: bool, optional, Flag to determine if the angle should be returned in degrees or radians. Default is False (radians). Returns: - phase_angle: array or scalar, The angle of the complex number(s) in radians (by default) or degrees. It is the counterclockwise angle from the positive real axis."
  },
  "numpy.append": {
    "new_func": "concatenate_values",
    "description": "Joins a sequence of arrays along an existing axis. Parameters: - initial_array: array_like, The array to which values are appended. - additional_values: array_like, The values to append to the array. - axis: int, optional, The axis along which to append. If not provided, both initial_array and additional_values are flattened before use. Returns: - combined_array: array, The result of appending the values to the array. The appended array is not modified in place; a new array is allocated and returned."
  },
  "numpy.apply_along_axis": {
    "new_func": "execute_across_dimension",
    "description": "Execute a 1-dimensional function across a specified dimension of an array. This method applies the given function to 1-D slices of an array along the chosen axis. It is more efficient than iterating with index arrays.\nParameters:\n- func1d (function): Function accepting 1-D arrays to be applied to 1-D slices.\n- axis (int): Dimension of the array along which to apply the function.\n- arr (array_like): Input data array.\n- args (tuple): Additional positional arguments to pass to func1d.\n- kwargs (dict): Additional keyword arguments to pass to func1d.\nReturns:\n- out (array_like): An array with the same shape as the input array, except along the specified axis, replaced with the shape of the return value from func1d."
  },
  "numpy.apply_over_axes": {
    "new_func": "execute_across_multiple_dimensions",
    "description": "Apply a function iteratively over multiple specified axes of an array. The function is called on the array with the axis parameter being the first element of the axes sequence. The result must have the same number of dimensions as the input or one less.\nParameters:\n- func (function): Function to apply, taking an array and an axis argument.\n- a (array_like): Array to apply the function on.\n- axes (array_like): Sequence of axes over which to apply the function.\nReturns:\n- apply_over_axis (array): An array with the same number of dimensions as the input, but potentially different shape, depending on the output of func."
  },
  "numpy.arange": {
    "new_func": "equidistant_sequence",
    "description": "Create an array containing evenly spaced values within a specified range. The function accepts various numbers of positional arguments to determine the start, stop, and step of the sequence.\nParameters:\n- start (number, optional): The beginning value of the sequence, defaults to 0 if not provided.\n- stop (number): The end value of the sequence, which is not included in the output array.\n- step (number, optional): The difference between consecutive values, defaults to 1 if not provided.\n- dtype (dtype, optional): Desired data-type for the array.\n- device (str, optional): Device on which to place the array, defaults to None.\n- like (array_like, optional): Reference object for array creation.\nReturns:\n- equidistant_sequence (array): Array of evenly spaced values."
  },
  "numpy.arccos": {
    "new_func": "inverse_cosine",
    "description": "Compute the trigonometric inverse cosine for each element of an array. It returns the angle whose cosine is the input value, with a range of [0, pi] for real inputs.\nParameters:\n- x (array_like): Values to compute the inverse cosine for. For real inputs, the values should be within the interval [-1, 1].\n- out (array, optional): Alternate output array in which to place the result.\n- where (array_like, optional): Condition array that specifies where the operation should be performed.\nReturns:\n- angle (array): The angles in radians for each input value within the domain."
  },
  "numpy.arccosh": {
    "new_func": "inverse_hyperbolic_cosine",
    "description": "Calculate the inverse hyperbolic cosine of each element in an array. The function determines the value whose hyperbolic cosine matches the input array elements.\nParameters:\n- x (array_like): Input values for which the inverse hyperbolic cosine is calculated.\n- out (array, optional): Alternate output array in which to place the result.\n- where (array_like, optional): Condition array that specifies where the operation should be performed.\nReturns:\n- arccosh (array): The values of the inverse hyperbolic cosine for each input element."
  },
  "numpy.arcsin": {
    "new_func": "inverse_sine_radians",
    "description": "Calculates the trigonometric inverse sine of each element in the input array, expressed in radians. The output values are confined within the interval [-\u03c0/2, \u03c0/2].\nParameters:\n- x (array_like): Input array of y-coordinates on the unit circle.\n- out (array, None, optional): Alternative output array in which to place the result.\n- where (array_like, optional): Condition array determining where operation is applied.\n- **kwargs: Additional arguments for fine control.\nReturns:\n- angle (array): The angles whose sine is x, ranging from [-\u03c0/2, \u03c0/2]."
  },
  "numpy.arcsinh": {
    "new_func": "inverse_hyperbolic_sine_radians",
    "description": "Computes the hyperbolic inverse sine of each element in the input array, element-wise. The function returns an array with the same shape as the input array.\nParameters:\n- x (array_like): Input array of values.\n- out (array, None, optional): Alternative output array in which to place the result.\n- where (array_like, optional): Condition array determining where operation is applied.\n- **kwargs: Additional arguments for fine control.\nReturns:\n- out (array or scalar): The hyperbolic inverse sine of the input array, with the same shape as x."
  },
  "numpy.arctan": {
    "new_func": "inverse_tangent_radians",
    "description": "Yields the trigonometric inverse tangent of each element in the input array, with the output in radians. The result's real part is within the interval [-\u03c0/2, \u03c0/2].\nParameters:\n- x (array_like): Input values.\n- out (array, None, optional): Alternative output array to place the result.\n- where (array_like, optional): Condition array for selective computation.\n- **kwargs: Additional arguments for advanced control.\nReturns:\n- out (array or scalar): The inverse tangent of the input array, within the range [-\u03c0/2, \u03c0/2]."
  },
  "numpy.arctan2": {
    "new_func": "quadrant_corrected_inverse_tangent",
    "description": "Computes the quadrant-aware inverse tangent of the quotient of two arrays. The angle in radians is measured from the positive x-axis to the point defined by the coordinates (x2, x1).\nParameters:\n- x1 (array_like): Y-coordinates, real-valued.\n- x2 (array_like): X-coordinates, real-valued.\n- out (array, None, optional): Alternative output array to store the result.\n- where (array_like, optional): Condition array for where to apply the operation.\n- **kwargs: Additional arguments for more control.\nReturns:\n- angle (array): The angles in radians, within the range [-\u03c0, \u03c0]."
  },
  "numpy.argmax": {
    "new_func": "maximum_indices",
    "description": "Identifies the indices of the maximum values across the specified axis in an array. If the maximum value occurs multiple times, only the index of the first occurrence is returned.\nParameters:\n- a (array_like): Input array to find the indices of maximum values.\n- axis (int, optional): The dimension along which to find indices of the maximum. By default, the index is computed for the flattened array.\n- out (array, optional): Array to store the result.\n- keepdims (bool, optional): If set to True, the reduced dimensions are retained with size one.\nReturns:\n- index_array (array): An array of indices of the maximum values."
  },
  "numpy.around": {
    "new_func": "decimal_adjustment",
    "description": "Modifies an array's elements to a specified number of decimal places.\nParameters:\n- a: array_like, The input data.\n- decimals: int, The number of decimal places to round to. Default is 0.\n- out: array, optional, Alternative output array in which to place the result.\nReturns:\n- result: array, An array with the same shape as the input, with elements adjusted to the specified number of decimals."
  },
  "numpy.array": {
    "new_func": "multidimensional_container",
    "description": "Creates a structure that can hold multi-axial, uniform-type data. Parameters: - shape: tuple of ints, Specifies the dimensions of the container. - data_type: data-type, optional, Designates the desired type for the elements. Defaults to float. - buffer: object exposing buffer interface, optional, Source data to initialize the array. - offset: int, optional, Starting point in buffer. - strides: tuple of ints, optional, Steps to take when traversing dimensions. - order: {'C', 'F'}, optional, Memory layout of the structure. Returns a newly instantiated container with the specified properties."
  },
  "numpy.array2string": {
    "new_func": "matrix_visualization",
    "description": "Generates a textual representation of a matrix.\nParameters:\n- a: array, The matrix to represent as a string.\n- max_line_width: int, optional, Newline insertion threshold in characters.\n- precision: int or None, optional, Numeric precision for floating-point values.\n- suppress_small: bool, optional, Whether to represent near-zero values as zero.\n- separator: str, optional, Delimiter between elements.\n- prefix: str, optional, String to prepend to the representation.\n- suffix: str, optional, String to append to the representation.\n- formatter: dict of callables, optional, Custom formatters for specific data types.\n- threshold: int, optional, Element count threshold for summarization.\n- edgeitems: int, optional, Number of edge items to display per dimension.\n- sign: {'-', '+', ' '}, optional, Floating-point sign representation.\n- floatmode: str, optional, Interpretation of the precision option for floating-point values.\n- legacy: string or False, optional, Enable legacy printing mode.\nReturns:\n- array_str: str, The string representation of the input matrix."
  },
  "numpy.array_equal": {
    "new_func": "matrix_identity_check",
    "description": "Determines if two matrices are identical in shape and content.\nParameters:\n- a1: array_like, First input matrix.\n- a2: array_like, Second input matrix.\n- equal_nan: bool, Whether to consider NaN values as equal. Applies to complex data types as well.\nReturns:\n- result: bool, True if matrices are identical, False otherwise."
  },
  "numpy.array_equiv": {
    "new_func": "consistency_verifier",
    "description": "Assesses if two matrices are equivalent, considering shape consistency and element-wise equality.\nParameters:\n- a1: array_like, First matrix for comparison.\n- a2: array_like, Second matrix for comparison.\nReturns:\n- outcome: bool, True if the matrices are shape consistent and all elements are equal, False otherwise."
  },
  "numpy.array_repr": {
    "new_func": "display_matrix",
    "description": "Returns a textual depiction of an array. This representation includes the array elements arranged in the shape of the array, with options to control line width, numerical precision, and small number suppression.\nParameters:\n- arr (array): The input array to represent.\n- max_line_width (int, optional): Newlines are inserted if the text exceeds this width.\n- precision (int, optional): Sets the precision for floating-point numbers.\n- suppress_small (bool, optional): When true, numbers close to zero are shown as zero.\nReturns:\n- (str): A string that visually represents the array structure and contents."
  },
  "numpy.array_split": {
    "new_func": "divide_series",
    "description": "Divides an array into multiple parts, potentially of unequal sizes, according to a specified number of divisions or explicit indices.\nParameters:\n- ary (array_like): The array to be divided.\n- indices_or_sections (int or 1-D array): An integer indicating the number of equal parts to divide into or a 1-D array of indices where the splits should occur.\n- axis (int, optional): The axis along which to split, default is 0.\nReturns:\n- list of arrays: A list containing the resulting sub-arrays after division."
  },
  "numpy.array_str": {
    "new_func": "concise_matrix",
    "description": "Generates a concise string depiction of array data, focusing on the data content without additional type or array structure information.\nParameters:\n- a (array): The array to convert into a string.\n- max_line_width (int, optional): Inserts line breaks beyond this width.\n- precision (int, optional): Specifies the floating-point precision for the output.\n- suppress_small (bool, optional): Rounds small numbers to zero in the output.\nReturns:\n- (str): A string that represents the data of the array."
  },
  "numpy.asanyarray": {
    "new_func": "promote_to_array",
    "description": "Transforms the input into an array format, while preserving subclass instances without conversion.\nParameters:\n- a (array_like): The input data to be converted.\n- dtype (data-type, optional): The desired data type for the array; by default, the data type is inferred from the input data.\n- order ({'C', 'F', 'A', 'K'}, optional): Specifies the desired memory layout of the output array.\n- like (array_like, optional): A reference object for creating arrays with a protocol compatible with the given object.\nReturns:\n- out (array or subclass): The array interpretation of the input data. If the input is already an array or a subclass, it is returned without copying."
  },
  "numpy.ascontiguousarray": {
    "new_func": "enforce_c_order",
    "description": "Ensures the input array has a contiguous memory layout in row-major order.\nParameters:\n- a (array_like): The input array.\n- dtype (str or dtype object, optional): The desired data type for the returned array.\n- like (array_like, optional): A reference object to create an array with a compatible protocol.\nReturns:\n- out (array): A contiguous array with the same content as the input array, potentially with a different type if specified."
  },
  "numpy.asarray": {
    "new_func": "array_cast",
    "description": "Transforms the given input into an array representation. Parameters: - input_data: Any form that can be transformed into an array, including nested sequences and arrays. - data_type: Optional, the desired data type for the array. If not provided, it is inferred from the input. - memory_layout: Optional, the desired memory layout of the array ('C', 'F', 'A', or 'K'). - target_device: Optional, specifies the device to place the array on. Only 'cpu' is allowed for interoperability. - make_copy: Optional, dictates whether to create a copy of the object. - reference_type: Optional, allows creation of arrays compatible with the reference object. Returns: - result_array: An array interpretation of the input. If the input is already a matching array, no copy is made."
  },
  "numpy.asarray_chkfinite": {
    "new_func": "array_ensure_finite",
    "description": "Transforms input into an array while ensuring all elements are finite values, raising an error if any elements are not finite. Parameters: - input_data: Data to be converted into an array. Must not contain NaNs or Infs. - data_type: Optional, the desired data type for the array. - memory_layout: Optional, the desired memory layout of the array. Returns: - result_array: An array interpretation of the input with guaranteed finite values. Raises: - ValueError: If the input contains NaNs or Infs."
  },
  "numpy.asfortranarray": {
    "new_func": "column_major_array",
    "description": "Converts the given input into an array with Fortran-like index order, ensuring that the returned array is laid out in memory as a column-major array. Parameters: - input_data: The input array to be converted. - data_type: Optional, specifies the desired data type of the resulting array. - reference_type: Optional, for creating arrays compatible with a reference object. Returns: - column_array: The input as an array with column-major memory order."
  },
  "numpy.asin": {
    "new_func": "inverse_sine",
    "description": "Computes the angle whose sine is the given input value, element-wise, in radians. Parameters: - input_value: The y-coordinate on the unit circle for which to compute the angle. - output_array: Optional, the array to store the results. - conditions: Optional, specifies where to apply the operation. - additional_params: Other optional parameters to specify casting rules, memory layout, etc. Returns: - angle_array: The angles in radians corresponding to the sine values provided, in the range [-\u03c0/2, \u03c0/2]."
  },
  "numpy.asinh": {
    "new_func": "inverse_hyperbolic_sine",
    "description": "Calculates the inverse hyperbolic sine of the input values, element-wise. Parameters: - input_value: The value for which to calculate the inverse hyperbolic sine. - output_array: Optional, a location to store the computed values. - conditions: Optional, where to apply the computation. - additional_params: Other optional parameters. Returns: - output_value: The inverse hyperbolic sine of each input element."
  },
  "numpy.asmatrix": {
    "new_func": "interpret_as_2d",
    "description": "Interpret the provided data as a 2-dimensional array structure without copying if it is already in an appropriate format. Parameters: - data (array_like): Input data to be interpreted. - dtype (data-type, optional): Desired data-type for the output, default is None which means the data-type of the input is used. Returns: - mat (matrix): The input data cast as a 2-dimensional array structure."
  },
  "numpy.atan": {
    "new_func": "inverse_tangent",
    "description": "Compute the trigonometric inverse tangent, element-wise, of the input array. This function returns the angle whose tangent is the input value, with a range of [-pi/2, pi/2]. Parameters: - x (array_like): Input values. - out (array, optional): Alternative output array in which to place the result. It must have the same shape as the expected output. - where (array_like, optional): A boolean array which is broadcasted to determine where the results are set. Returns: - out (array or scalar): The angles in radians, with the real part of the output in the interval [-pi/2, pi/2]."
  },
  "numpy.atan2": {
    "new_func": "quadrant_corrected_arc_tangent",
    "description": "Calculate the arc tangent of x1/x2 using the signs of both arguments to determine the correct quadrant of the return value. The result is the angle formed by the x-axis and a vector to the point (x2, x1). Parameters: - x1 (array_like, real-valued): y-coordinates. - x2 (array_like, real-valued): x-coordinates. Returns: - angle (array): The calculated angles in radians, within the range [-pi, pi]."
  },
  "numpy.atanh": {
    "new_func": "inverse_hyperbolic_tangent",
    "description": "Calculate the inverse hyperbolic tangent of the input array, element-wise. The function returns a value with an imaginary part in the interval [-pi/2, pi/2]. Parameters: - x (array_like): Input array. Returns: - out (array or scalar): The calculated inverse hyperbolic tangent values, with the same shape as the input array."
  },
  "numpy.atleast_1d": {
    "new_func": "ensure_min_dimensionality",
    "description": "Ensure that all input arrays have at least one dimension. Scalars are converted to 1-dimensional arrays, while higher-dimensional inputs are left unchanged. Parameters: - arys1, arys2, \u2026 (array_like): One or more input arrays. Returns: - ret (array or tuple of arrays): An array or a tuple of arrays, each with ndim >= 1. Copies are made only if necessary."
  },
  "numpy.atleast_2d": {
    "new_func": "guarantee_min_twodim",
    "description": "Transform input into arrays with a minimum of two dimensions. If the input already has two or more dimensions, it is returned unchanged. For inputs with lower dimensions, a new array with an additional axis is created to meet the requirement. This function is useful for ensuring that inputs are compatible with operations that require at least two-dimensional arrays. Parameters: - arys: one or more input sequences. Non-array inputs are cast to arrays. Returns: - An array or a tuple of arrays, each with at least two dimensions. Wherever possible, views rather than copies are returned."
  },
  "numpy.binary_repr": {
    "new_func": "integer_to_binary_string",
    "description": "Creates a string representation of a decimal integer in its binary form. If the integer is negative and no width is specified, the result includes a leading minus sign. For negative integers with a specified width, the function returns the binary two's complement representation. Parameters: - num: the integer to be converted. - width (optional): the length of the resulting binary string or two's complement for negative integers. Returns: - A string representing the binary equivalent of the given integer."
  },
  "numpy.bartlett": {
    "new_func": "triangular_apodization",
    "description": "Generates a window with a triangular shape, commonly used for signal processing applications such as tapering a signal with minimal frequency domain ripple. The vertex of the triangle is normalized to one, and the window tapers down to zero at the endpoints. Parameters: - M: the number of points in the resulting window. Returns: - An array representing the triangular window, with a maximum value of one and endpoints at zero."
  },
  "numpy.base_repr": {
    "new_func": "number_to_custom_base",
    "description": "Converts an integer to its string representation in a specified base, ranging from binary to base-36. Parameters: - number: the integer value to convert. - base (optional): the base to use for the conversion, defaulting to binary. - padding (optional): the number of leading zeros to include in the result. Returns: - A string representing the integer in the specified base, with optional padding."
  },
  "numpy.bincount": {
    "new_func": "count_value_occurrences",
    "description": "Calculates the frequency of each non-negative integer in an array. The output array's length is determined by the highest integer in the input, with an optional minimum length. If weights are provided, they are used to weight the count instead of simply incrementing by one. Parameters: - x: one-dimensional input array with non-negative integers. - weights (optional): array of weights, must be the same shape as x. - minlength (optional): minimum number of output bins. Returns: - An array containing the count of occurrences of each integer in the input array."
  },
  "numpy.bitwise_and": {
    "new_func": "elementwise_intersection",
    "description": "Performs a conjunction operation on each pair of elements in two input arrays, treating their binary representations. The result is an array with the binary AND applied to the corresponding elements. Parameters: - x1, x2 (array_like): Arrays containing integer or boolean values. They must either have the same shape or be broadcastable to a common shape. - out (array, optional): Alternate output array to store the results. It must be broadcastable to the input shape. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments for fine-tuning, detailed in the advanced documentation. Returns: - out (array or scalar): The result of the element-wise binary AND operation."
  },
  "numpy.bitwise_invert": {
    "new_func": "elementwise_complement",
    "description": "Calculates the bitwise complement of elements in the input array, effectively flipping all binary bits in each element. If integers are signed, the operation returns the two's complement. Parameters: - x (array_like): Input array containing integer or boolean values. - out (array, optional): Alternate output array to store the results. It must be broadcastable to the input shape. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments for fine-tuning, detailed in the advanced documentation. Returns: - out (array or scalar): An array with the bitwise NOT applied to each element."
  },
  "numpy.bitwise_left_shift": {
    "new_func": "elementwise_binary_scale_up",
    "description": "Shifts the binary digits of an integer array's elements to the left by a specified number of places, equivalent to multiplying by a power of two. Parameters: - x1 (array_like of integer type): Values to shift. - x2 (array_like of integer type): Number of positions to shift digits to the left. Must be non-negative. - out (array, optional): Alternate output array to store the results. It must be broadcastable to the input shape. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments for fine-tuning, detailed in the advanced documentation. Returns: - out (array of integer type): An array with the bits shifted to the left."
  },
  "numpy.bitwise_count": {
    "new_func": "population_cardinality",
    "description": "Determines the quantity of '1' bits present in the binary representation of each element in the input array. Parameters: - x (array_like, unsigned int): Input array for which to count '1' bits. - out (array, optional): Alternate output array to store the results. It must be broadcastable to the input shape. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments for fine-tuning, detailed in the advanced documentation. Returns: - y (array): An array of unsigned 8-bit integers representing the count of '1' bits in each input element."
  },
  "numpy.bitwise_or": {
    "new_func": "elementwise_union",
    "description": "Executes a binary union operation on each pair of elements in two input arrays, based on their binary representations. The operation results in an array with the binary OR applied to corresponding elements. Parameters: - x1, x2 (array_like): Arrays containing integer or boolean values. They must either have the same shape or be broadcastable to a common shape. - out (array, optional): Alternate output array to store the results. It must be broadcastable to the input shape. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments for fine-tuning, detailed in the advanced documentation. Returns: - out (array or scalar): The result of the element-wise binary OR operation."
  },
  "numpy.blackman": {
    "new_func": "cosine_taper_window",
    "description": "Generates a specific symmetric window of a certain size with a cosine shape. This window is designed to minimize spectral leakage and is often used in signal processing for tapering signals. It is characterized by three terms in its formula, providing a trade-off between main lobe width and side lobe level, which results in reduced leakage compared to other windows such as rectangular ones.\nParameters:\n- size: int, Number of points in the output window. An empty array is returned for non-positive values.\nReturns:\n- window_sequence: array, The tapered window of specified size with a peak normalized to one (peak value of one appears if size is odd)."
  },
  "numpy.bitwise_xor": {
    "new_func": "elementwise_exclusive_or",
    "description": "Performs an element-wise exclusive OR operation on two arrays, comparing their binary representations and combining them according to the XOR logic gate rules. This operation is equivalent to the '^' operator for arrays.\nParameters:\n- array1, array2: array_like, Input arrays containing integer or boolean types. They must be broadcastable to a common shape, which will be the shape of the resulting array.\n- output: array, optional, A location into which the result is stored. If not provided or set to None, a new array is created for the output.\n- condition: array_like, optional, A boolean array that specifies where the operation is carried out.\nReturns:\n- result: array or scalar, The result of the XOR operation. A scalar is returned if both inputs are scalars."
  },
  "numpy.block": {
    "new_func": "assemble_array",
    "description": "Constructs a multi-dimensional array from a nested list of blocks or arrays. The blocks are concatenated along the corresponding dimensions, starting from the innermost list and progressing outward. This function does not broadcast blocks but will prepend leading axes of size 1 as necessary to align dimensions.\nParameters:\n- blocks: nested list of array_like or scalars, Input blocks to assemble. The list may be deeply nested, and the shapes of the blocks must match appropriately along the relevant axes.\nReturns:\n- assembled_array: array, The array constructed from the input blocks, having the maximum dimensionality among the inputs or the depth of the nested list."
  },
  "numpy.bitwise_right_shift": {
    "new_func": "binary_shift_right",
    "description": "Applies a binary right shift to each element of an integer array, effectively dividing each element by the power of two specified by the shift amount.\nParameters:\n- value_array: array_like, int, The array of integers to be shifted.\n- shift_array: array_like, int, The number of positions by which bits are to be shifted to the right.\n- output: array, optional, A location into which the result is stored. If not specified, a new array is allocated.\n- condition: array_like, optional, Specifies where the operation should take place. The operation is applied where the condition is True.\nReturns:\n- shifted_array: array, int, The result of shifting the bits of the input array to the right by the specified amount. Returns a scalar if both inputs are scalars."
  },
  "numpy.bmat": {
    "new_func": "matrix_assembler",
    "description": "Creates a matrix from a string representation, a nested sequence of arrays, or an array-like object. If a string is provided, it may reference variables by name from the current scope.\nParameters:\n- source: str or array_like, The input data to form the matrix.\n- local_dict: dict, optional, A dictionary to substitute local variables in the current scope if the source is a string.\n- global_dict: dict, optional, A dictionary to substitute global variables in the current scope if the source is a string.\nReturns:\n- matrix_object: matrix, A 2-D matrix constructed from the input data."
  },
  "numpy.broadcast": {
    "new_func": "expand_dimensions",
    "description": "Creates an object that simulates dimension expansion for the purpose of aligning shapes. This object can be utilized as an iterator and possesses attributes such as shape and number of dimensions.\n\nParameters:\n- *args: array_like, Input arrays for dimension alignment.\n\nReturns:\n- broadcasted_object: An entity that contains the expanded dimension result, having attributes such as shape and number of dimensions."
  },
  "numpy.broadcast_shapes": {
    "new_func": "merge_dimensions",
    "description": "Combines multiple shape tuples, ensuring they conform to broadcasting rules, resulting in a single unified shape.\n\nParameters:\n- *args: tuples of ints or ints, The collection of shapes to be unified.\n\nReturns:\n- unified_shape: tuple, The combined shape after successful broadcasting."
  },
  "numpy.broadcast_arrays": {
    "new_func": "align_arrays",
    "description": "Adjusts a set of arrays so that they all have the same shape according to broadcasting rules. The adjusted arrays are views of the originals, sharing memory locations.\n\nParameters:\n- *args: array_likes, Arrays to be shape-aligned.\n- subok: bool, optional, Preserves sub-classes if True, otherwise returns base-class arrays. Default is False.\n\nReturns:\n- aligned_arrays: tuple of arrays, The shape-aligned arrays as views with shared memory locations."
  },
  "numpy.broadcast_to": {
    "new_func": "shape_upscale",
    "description": "Generates a view of the given array with the specified shape, applying broadcasting rules. The view is non-writable and may have shared memory locations.\n\nParameters:\n- array: array_like, The array to be reshaped.\n- shape: tuple or int, The desired shape, interpreted as a tuple.\n- subok: bool, optional, Whether to preserve sub-classes or return a base-class array. Default is False.\n\nReturns:\n- upscaled_array: array, A view on the original array with expanded shape."
  },
  "numpy.can_cast": {
    "new_func": "check_type_compatibility",
    "description": "Evaluates if a type conversion is possible between two data types based on a specified casting rule.\n\nParameters:\n- from_: dtype, dtype specifier, scalar, or array, Type or object to evaluate conversion from.\n- to: dtype or dtype specifier, Target type for conversion.\n- casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, Controls permitted casting types.\n\nReturns:\n- is_castable: bool, Indicates if the conversion is possible following the casting criteria."
  },
  "numpy.ceil": {
    "new_func": "integer_ceil",
    "description": "Compute the smallest integer greater than or equal to each element of the input array. Parameters: - x (array_like): Input data. - out (array, None, or tuple of array and None, optional): Destination for the operation's result. - where (array_like, optional): Condition that decides where the operation should be applied. - **kwargs: Additional keyword arguments for advanced usage. Returns: - y (array or scalar): The output array with integers equal to or greater than the input, having float dtype. This will be a scalar if the input is scalar."
  },
  "numpy.cbrt": {
    "new_func": "cube_root",
    "description": "Calculate the cube-root of each element in the input array. Parameters: - x (array_like): Input values to compute the cube-root for. - out (array, None, or tuple of array and None, optional): A location into which the result is stored. - where (array_like, optional): Condition to apply the operation selectively. - **kwargs: Additional keyword arguments. Returns: - y (array): An array with the cube-root of each element in the input. A reference to the provided out if given, otherwise a new array."
  },
  "numpy.c_": {
    "new_func": "horizontal_stack_slices",
    "description": "Combine arrays by stacking them horizontally (column-wise). This is a shortcut for concatenation operations that are frequently used. Parameters: - index expression (slice, array_like): Expressions that define the arrays to be concatenated. Returns: - result (array): The array resulting from the concatenation of the input arrays along the second axis."
  },
  "numpy.busdaycalendar": {
    "new_func": "workday_calendar",
    "description": "Construct an object to represent a calendar that defines valid business days. Parameters: - weekmask (str or array_like of bool, optional): Indicates valid days of the week. - holidays (array_like of datetime64[D], optional): Dates to be considered as non-business days. Returns: - out (busdaycalendar): An object representing the specified calendar, with attributes containing copies of the weekmask and holidays."
  },
  "numpy.busday_count": {
    "new_func": "workday_differential",
    "description": "Calculate the total number of valid business days between two dates, excluding the end date. Parameters: - begindates (array_like of datetime64[D]): Start dates for the count. - enddates (array_like of datetime64[D]): End dates for the count, not included in the count. - weekmask (str or array_like of bool, optional): Mask for valid weekdays. - holidays (array_like of datetime64[D], optional): Dates to exclude from the count. - busdaycal (busdaycalendar, optional): Predefined calendar object specifying valid days. - out (array of int, optional): Array to store the result. Returns: - out (array of int): Array with the number of valid days between the given start and end dates."
  },
  "numpy.copy": {
    "new_func": "duplicate_array",
    "description": "Create a duplicate of the specified array with the option to preserve subclass types and control the memory layout of the result. Parameters: - source_array: array_like, The array to duplicate. - memory_order: {'C', 'F', 'A', 'K'}, Controls the memory layout. - preserve_subclass: bool, Whether to preserve subclass types. Returns: - duplicate: array, A duplicate of the input array."
  },
  "numpy.copyto": {
    "new_func": "transfer_elements",
    "description": "Transfer elements from one array to another with optional broadcasting. Raises TypeError for invalid casting rules. Parameters: - destination: array, The recipient array. - source: array_like, The donor array. - casting_rule: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, Dictates allowed data casting. - condition: array_like of bool, Specifies which elements to copy. Returns: None, The operation modifies the destination array in-place."
  },
  "numpy.corrcoef": {
    "new_func": "pearson_coefficient_matrix",
    "description": "Compute the Pearson product-moment correlation coefficients matrix for given variables and observations. Parameters: - variables: array_like, Variables with observations. - additional_variables: array_like, More variables and observations. - use_columns: bool, Interpret rows as variables if True. - result_type: data-type, Specifies the result's data type. Returns: - correlation_matrix: array, A matrix containing the correlation coefficients."
  },
  "numpy.correlate": {
    "new_func": "sequence_correlation",
    "description": "Calculate the cross-correlation of two one-dimensional sequences with optional zero-padding. Parameters: - sequence1, sequence2: array_like, Input sequences to correlate. - correlation_mode: {'valid', 'same', 'full'}, Specifies the size of the output. Returns: - correlation_output: array, The cross-correlation of the input sequences."
  },
  "numpy.cosh": {
    "new_func": "hyperbolic_cosine",
    "description": "Compute the hyperbolic cosine for each element in the input array. Parameters: - input_array: array_like, Input values. - output: array, Optional output array to store the result. - conditions: array_like, Where True, compute the hyperbolic cosine. Other keyword arguments for advanced use. Returns: - result: array or scalar, The hyperbolic cosine of the input array."
  },
  "numpy.count_nonzero": {
    "new_func": "tally_truthful_elements",
    "description": "Tallies elements within an array that evaluate to a logical 'true' based on their inherent truthfulness, as characterized by their non-equivalence to zero. This evaluation is consistent with Python's truth value testing.\nParameters:\n- input_array (array_like): The array within which to count truthful elements.\n- axis (int or tuple, optional): The dimension(s) along which to count the elements. If None, counts across a flattened version of the array.\n- keepdims (bool, optional): If set to True, retains reduced axes with length one, facilitating broadcasting with the original array.\nReturns:\n- count (int or array of int): The tally of truthful elements along the specified axis or axes, or the total count if no axis is specified."
  },
  "numpy.cov": {
    "new_func": "variance_matrix",
    "description": "Calculates a matrix describing the mutual variability of multiple observations of possibly correlated variables.\nParameters:\n- observations (array_like): A two-dimensional array with variables as rows and observations as columns.\n- additional_observations (array_like, optional): An additional set of variables and observations.\n- variable_orientation (bool, optional): Dictates whether rows (default) or columns represent variables.\n- normalization_bias (bool, optional): Determines normalization by the number of observations minus one (default) or by the number of observations.\n- delta_degrees_of_freedom (int, optional): Overrides the default normalization factor.\n- freq_weights (array_like, int, optional): Integer weights for the frequency of observations.\n- analysis_weights (array_like, optional): Weights for each observation vector, representing their relative importance.\n- result_dtype (data-type, optional): Desired data-type for the result.\nReturns:\n- covariance_matrix (array): The calculated matrix of variance and covariance between variables."
  },
  "numpy.cross": {
    "new_func": "vector_product",
    "description": "Computes the perpendicular product of two vectors or arrays of vectors, commonly known as the vector product. For bidimensional vectors, the third component is assumed to be zero.\nParameters:\n- vector1 (array_like): The first input vector or array of vectors.\n- vector2 (array_like): The second input vector or array of vectors.\n- vector1_axis (int, optional): The axis of the first array that defines the vectors.\n- vector2_axis (int, optional): The axis of the second array that defines the vectors.\n- result_axis (int, optional): The axis of the result that contains the product vectors.\n- unified_axis (int, optional): Specifies the axis that defines the vectors for both input arrays and the resulting array.\nReturns:\n- product (array): The vector product of the input vectors, perpendicularly oriented to both."
  },
  "numpy.cos": {
    "new_func": "circular_ratio",
    "description": "Computes the trigonometric ratio associated with the angle of a circle's radius with the x-axis, known as the cosine function.\nParameters:\n- radian_input (array_like): Input array containing angles in radians.\n- output_array (array, None, or tuple of array and None, optional): A location for storing the computed values. If provided, it must be broadcastable to match the input shape.\n- condition (array_like, optional): A boolean array that determines where the calculation is performed; the result is stored at True locations.\nReturns:\n- result (array): An array of the cosine values for the provided radian inputs."
  },
  "numpy.datetime_data": {
    "new_func": "time_unit_info",
    "description": "Retrieves the step size and unit information for a datetime or timedelta data type.\nParameters:\n- time_dtype (dtype): The data type object, either datetime64 or timedelta64, to analyze.\nReturns:\n- unit_info (tuple): A tuple containing the unit as a string and the count as an integer, representing the base unit and the number of these units constituting a step."
  },
  "numpy.datetime_as_string": {
    "new_func": "timestamp_to_textual",
    "description": "Transforms an array of datetime objects into a corresponding array of formatted strings. Parameters: - arr (array_like of datetime64): Array containing UTC timestamps. - unit (str): Granularity unit for formatting, 'auto' or a datetime unit. - timezone ({'naive', 'UTC', 'local'} or tzinfo): Timezone information for displaying dates. If a tzinfo object is supplied, the conversion will honor that specific timezone. - casting ({'no', 'equiv', 'safe', 'same_kind', 'unsafe'}): Controls the casting rules when changing datetime units. Returns: - str_arr (array): An array with the same shape as arr, containing the formatted date and time strings."
  },
  "numpy.deg2rad": {
    "new_func": "degrees_to_radians",
    "description": "Converts angles from degrees to radians. Parameters: - x (array_like): Input array of angles in degrees. - out (array, None, or tuple of array and None, optional): A location where the result is stored. - where (array_like, optional): A boolean array that is broadcast over the input to determine where the conversion is applied. Returns: - y (array): An array of angles in radians with the same shape as the input."
  },
  "numpy.delete": {
    "new_func": "remove_elements",
    "description": "Creates a new array by removing specified elements from an input array. Parameters: - arr (array_like): Initial array. - obj (slice, int, or array of ints): Indices of elements or slices to remove. - axis (int, optional): Axis along which elements should be removed. If None, the function will be applied to the flattened array. Returns: - out (array): Array with the requested elements removed."
  },
  "numpy.diag": {
    "new_func": "diagonal_extractor",
    "description": "Retrieves a diagonal from a 2-D array or constructs a diagonal array from a 1-D array. Parameters: - v (array_like): If a matrix, the function returns the k-th diagonal. If a vector, it returns a matrix with the vector as the k-th diagonal. - k (int, optional): Specifies which diagonal to extract or create. Defaults to the main diagonal (0). Above the main diagonal for positive k, below for negative k. Returns: - out (array): The extracted diagonal as a 1-D array or a 2-D array with the specified diagonal."
  },
  "numpy.diag_indices": {
    "new_func": "main_diagonal_locator",
    "description": "Provides the indices required to access the main diagonal of a square multi-dimensional array. Parameters: - n (int): The size of each dimension for the arrays that the indices can be used. - ndim (int, optional): The number of dimensions for the array, default is 2. Returns: - tuple of arrays: A tuple containing arrays of indices for accessing the main diagonal."
  },
  "numpy.diag_indices_from": {
    "new_func": "main_diagonal_locator",
    "description": "Retrieve the indices to access the principal diagonal of a multi-dimensional square matrix. This function provides a convenient method for accessing the main diagonal positions of a matrix with two or more dimensions. Parameters: - arr: array_like, a matrix of at least 2 dimensions. Returns: - indices: tuple of arrays, with each array representing the row and column indices of the principal diagonal elements."
  },
  "numpy.diagflat": {
    "new_func": "flattened_to_diagonal",
    "description": "Transforms a flat input into a 2D array with the input elements forming a diagonal. Parameters: - input_data: array_like, the data to be transformed into a diagonal matrix. - diagonal_index: int, optional, the index of the diagonal to be filled with the input data, where 0 corresponds to the primary diagonal. Positive or negative values shift the diagonal above or below the main one, respectively. Returns: - diagonal_matrix: array, a 2D array with the input data on the specified diagonal and zeros elsewhere."
  },
  "numpy.diagonal": {
    "new_func": "selective_diagonal_extraction",
    "description": "Extracts elements from specified diagonals of an array, primarily for two-dimensional arrays. For arrays with more dimensions, it selects a 2D plane first and then extracts the diagonal. The function can also handle offsets to select diagonals not centered on the array. Parameters: - input_array: array_like, the array from which diagonals are to be extracted. - diagonal_offset: int, optional, defaults to zero for the main diagonal. Positive or negative values select diagonals above or below the main one. - axis1, axis2: int, optional, axes to define the 2D plane from which the diagonal is taken. Returns: - array_of_diagonals: array, an array containing the extracted diagonal elements."
  },
  "numpy.diff": {
    "new_func": "successive_differences",
    "description": "Computes the difference between consecutive elements along a specified axis, with the option to repeat the operation multiple times. Parameters: - input_array: array_like, the array on which differences are calculated. - differencing_order: int, optional, the number of times consecutive differences are taken. - axis_of_diff: int, optional, the axis along which to calculate the differences. - prepend, append: array_like, optional, values to add at the beginning or end of the axis before computing differences. Returns: - differences: array, an array of the same type as the input array containing the calculated differences."
  },
  "numpy.digitize": {
    "new_func": "bin_index_assignment",
    "description": "Assigns each element in the input array to bins represented by intervals. Elements outside the range of bins are assigned to the first or last index. Parameters: - values: array_like, the input array of values to be binned. - thresholds: array_like, one-dimensional array of bin edges, which must be monotonic. - include_right: bool, optional, determines whether the bins include the right edge or the left edge by default. Returns: - bin_indices: array of ints, an array with the same shape as the input array, containing the indices of the bins to which each element belongs."
  },
  "numpy.divmod": {
    "new_func": "quotient_remainder_combination",
    "description": "Computes the quotient and remainder of division for input arrays simultaneously. This operation is more efficient than performing the floor division and modulo separately. It's suitable for applications that require both results of the division process. Parameters: - dividend (array_like): The array of numerators. - divisor (array_like): The array of denominators. Should be broadcastable to the shape of dividend. - out (tuple of array, optional): A location to store the results. Must be broadcast-compatible with the input arrays. If not provided, a new array is created. - where (array_like, optional): A condition array that determines where to apply the operation. Returns: - quotient (array): The result of floor division. Scalar if inputs are scalars. - remainder (array): The remainder from the division. Scalar if inputs are scalars."
  },
  "numpy.divide": {
    "new_func": "elementwise_fraction",
    "description": "Calculates the element-wise division of two input arrays. The shape of the output array is determined by broadcasting the shapes of the input arrays. Parameters: - dividend (array_like): The numerator array. - divisor (array_like): The denominator array. - out (array, optional): A location into which the result is stored. If not provided, a new array is returned. - where (array_like, optional): A condition array that specifies where the operation should take place. Returns: - quotient (array or scalar): The result of division. Scalar if both inputs are scalars."
  },
  "numpy.dot": {
    "new_func": "scalar_matrix_product",
    "description": "Calculates the dot product of two arrays. For 1-D arrays, it computes their inner product. For 2-D arrays, it performs matrix multiplication. For higher dimensions, it computes the sum product over the last and second-to-last axes. Parameters: - a (array_like): First input array. - b (array_like): Second input array. - out (array, optional): Output array for the result. Must be the correct shape and type. Returns: - product (array): The result of the dot product operation. If both inputs are scalars or 1-D arrays, a scalar is returned; otherwise, an array is returned. If 'out' is provided, it is returned. Raises: - ValueError: If the shapes of 'a' and 'b' are not aligned for the dot product."
  },
  "numpy.dsplit": {
    "new_func": "depthwise_splitter",
    "description": "Splits an array into multiple sub-arrays along the depth (3rd) axis. This function is intended for use with arrays of three or more dimensions. Parameters: - ary (array): The array to be divided. - indices_or_sections (int or 1-D array): If an integer, determines the equal sections to split into. If a 1-D array, determines the indices at which to split the array. Returns: - sub_arrays (list of arrays): A list of sub-arrays as views into ary."
  },
  "numpy.dstack": {
    "new_func": "depthwise_stacker",
    "description": "Stacks a sequence of arrays along the third axis after reshaping 1-D and 2-D arrays. It is particularly useful for stacking images with channels. Parameters: - tup (sequence of arrays): Arrays must have the same shape along all but the third axis. 1-D and 2-D arrays are reshaped accordingly. Returns: - stacked_array (array): The array resulting from stacking the input arrays, at least 3-D."
  },
  "numpy.dtype": {
    "new_func": "data_structure_type",
    "description": "Instantiates an object representing data type in an array. This construction method enables the creation of custom, compound, or primitive data types, potentially with additional alignment or metadata. Parameters: - type_obj: The input to be converted to a data structure type. - pad: When true, adds padding to the fields to ensure alignment similar to that of a C struct. Applicable only if type_obj is a dictionary or a string with comma-separated fields. - duplicate: When true, a new copy of the data type object is created. If false, may return a reference to a built-in data type. - info: A dictionary containing optional metadata for the data type. Returns: - data_structure: The new data type object representing the specified structure and metadata."
  },
  "numpy.ediff1d": {
    "new_func": "sequential_difference",
    "description": "Computes the differences between subsequent elements in an array. Parameters: - sequence: Input array that will be flattened if not already 1-D. - append_seq: Values to be appended at the end of the calculated differences. - prepend_seq: Values to be prepended at the beginning of the calculated differences. Returns: - differences: An array containing the calculated differences. If 'append_seq' or 'prepend_seq' are provided, these values are included as appropriate."
  },
  "numpy.einsum": {
    "new_func": "multilinear_transform",
    "description": "Performs a multilinear transformation of multiple input arrays based on the Einstein summation convention, which allows for concise representation of various linear algebraic operations. Parameters: - subscript_str: A string specifying the subscripts for summation and the output array's desired axes. - arrays: The arrays involved in the transformation process. - result_array: An optional output array to store the result. - data_type: An optional parameter to specify the data type of the result. - memory_order: Controls the memory layout of the output, with options 'C', 'F', 'A', or 'K'. - cast_type: Determines permissible data casting during computation. - is_optimized: Indicates whether to optimize the computation and can accept a boolean value or a specific contraction path. Returns: - transformed_array: The resulting array after applying the transformation."
  },
  "numpy.einsum_path": {
    "new_func": "optimal_summation_order",
    "description": "Determines the optimal order of operations for a multilinear transformation to minimize computational cost. Parameters: - subscript_str: A string that specifies the subscripts for summation. - arrays: The list of input arrays for the operation. - optimization_strategy: A flag or strategy to determine the optimization path. Can be a boolean, list, tuple, 'greedy', or 'optimal'. Returns: - contraction_path: A list of tuples indicating the order in which the input arrays should be contracted. - readable_path: A printable string representation of the contraction path."
  },
  "numpy.empty": {
    "new_func": "uninitialized_array",
    "description": "Generates an array with a specified shape and data type without initializing its values. Parameters: - dimensions: The shape of the array to create, as an integer or a tuple of integers. - element_type: The desired data type for the array elements. - storage_order: Determines whether the array is stored in row-major or column-major order. - device_placement: Optional parameter to specify the computational device for the array. - reference_type: Allows the creation of arrays that are compatible with the reference object. Returns: - raw_array: An array with uninitialized data of the given shape and data type."
  },
  "numpy.empty_like": {
    "new_func": "uninitialized_clone",
    "description": "Create an array with identical dimensions and type as an existing array, without initializing entries. Parameters: - prototype: The reference array whose shape and data-type determine the attributes of the resulting array. - dtype: Overrides the data type of the result (optional). - order: Memory layout of the result, C or Fortran style (optional). - subok: If True, the new array will be a subclass of the prototype if applicable (optional). - shape: Overrides the shape of the result (optional). - device: Specifies the device on which to place the array (optional). Returns: - An array with the same shape and type as the prototype but with arbitrary data."
  },
  "numpy.errstate": {
    "new_func": "floating_point_control",
    "description": "Manage the behavior of floating-point exceptions within a code block. Parameters: - kwargs: Dictates how floating-point errors are handled, with keys for different types of exceptions (e.g., 'divide', 'over', 'under', 'invalid') and corresponding values indicating the action (e.g., 'ignore', 'warn', 'raise'). Returns: - Context manager that sets the specified error handling behaviors for the duration of the context."
  },
  "numpy.equal": {
    "new_func": "elementwise_equality",
    "description": "Evaluate whether the elements of two arrays are equal on an element-by-element basis. Parameters: - x1, x2: Input arrays to be compared. If shapes differ, they must be broadcastable. - out: Optional output array to store the result. - where: Condition array; function is applied only at locations where condition is True (optional). - kwargs: Additional keyword arguments for detailed control (optional). Returns: - An array of booleans indicating equality of corresponding elements in the input arrays."
  },
  "numpy.exp": {
    "new_func": "elementwise_exponential",
    "description": "Compute the natural exponential function for each element in the input array. Parameters: - x: Values to exponentiate. - out: Optional output array to store the result. - where: Condition array; function is applied only at locations where condition is True (optional). - kwargs: Additional keyword arguments for detailed control (optional). Returns: - An array with the exponentiated values of the input array."
  },
  "numpy.exp2": {
    "new_func": "elementwise_power_of_two",
    "description": "Calculate two raised to the power of each element in the input array. Parameters: - x: The exponent values. - out: Optional output array to store the result. - where: Condition array; function is applied only at locations where condition is True (optional). - kwargs: Additional keyword arguments for detailed control (optional). Returns: - An array where each element is two raised to the power of the corresponding element in the input array."
  },
  "numpy.expand_dims": {
    "new_func": "augment_axes",
    "description": "Insert a new dimension to the array at the specified position, effectively increasing its rank. Parameters: - input_data (array_like): The input array. - new_axis_position (int or tuple of ints): The index or indices where the new dimension(s) is to be inserted. Returns: - reshaped_array (array): The array with added dimensions. This does not alter the original data, but returns a view with the new shape."
  },
  "numpy.extract": {
    "new_func": "retrieve_conditionally",
    "description": "Obtain elements from an array that meet a specified condition. Parameters: - filter_criteria (array_like): An array that determines which elements should be retrieved based on its non-zero or True entries. - source_array (array_like): The array from which elements are to be extracted, matching the size of filter_criteria. Returns: - selection (array): A one-dimensional array consisting of the elements from source_array where filter_criteria is True."
  },
  "numpy.expm1": {
    "new_func": "exp_minus_one",
    "description": "Compute the exponential of input values and subtract one, aiming to achieve higher precision for small input values. Parameters: - input_values (array_like): The values for which the computation is performed. - out (array, optional): Alternative output array in which to place the calculation. - where (array_like, optional): A boolean array that specifies where to perform the operation. Returns: - result (array or scalar): The computed values of exponential of input values minus one."
  },
  "numpy.eye": {
    "new_func": "identity_matrix",
    "description": "Create a two-dimensional square array with ones on a specified diagonal and zeros in the rest of the elements. Parameters: - rows (int): The number of rows for the array. - cols (int, optional): The number of columns for the array. - diagonal_index (int, optional): The index of the diagonal where ones will be filled. Returns: - diagonal_array (array): An array with ones on the specified diagonal and zeros elsewhere."
  },
  "numpy.fabs": {
    "new_func": "positive_magnitude",
    "description": "Calculate the non-negative magnitude of each element in the input array. This operation is for real numbers only, as it does not handle complex numbers. Parameters: - input_values (array_like): The array of numbers whose non-negative magnitudes are desired. - out (array, optional): Alternative output array to store the results. - where (array_like, optional): A boolean array that specifies where to perform the operation. Returns: - magnitude_array (array or scalar): The non-negative magnitudes of the input array elements."
  },
  "numpy.fill_diagonal": {
    "new_func": "populate_primary",
    "description": "Populate the primary diagonal of a multi-dimensional array with a specified value or pattern. This operation is performed in-place, altering the original array without producing a separate output. The primary diagonal is defined as the sequence of elements with identical multi-dimensional indices.\nParameters:\n- target_array: An array with at least two dimensions.\n- diagonal_value: A scalar or sequence to be written along the diagonal. If a scalar, this value populates the entire diagonal. If sequence-like, the values are used in order, repeating if necessary.\n- enable_wrapping: A boolean flag that, when set to True, allows the diagonal population to continue from the first column after reaching the last column in matrices with more rows than columns.\nNo return value, as the operation modifies the input array directly."
  },
  "numpy.finfo": {
    "new_func": "float_precision_limits",
    "description": "Retrieve the precision characteristics and limitations of floating-point or complex data types. This includes information such as the smallest increment, largest and smallest representable numbers, and the number of decimal digits of precision.\nParameters:\n- data_type: The data type to query, which can be a floating-point or complex data type.\nAttributes include the size in bits, machine epsilon values, and the range of exponents.\nReturns a class instance populated with the attributes of the queried data type."
  },
  "numpy.flip": {
    "new_func": "reverse_elements",
    "description": "Create a view of an array with elements reversed along one or more axes. The array's shape remains unchanged, but the elements are reordered as if by slicing with ::-1.\nParameters:\n- input_array: The array to be modified.\n- flip_axis: The axis or axes to reverse. By default, all axes are reversed.\nReturns:\n- reversed_array: A view of the original array with the specified axes elements reversed."
  },
  "numpy.fix": {
    "new_func": "round_towards_zero",
    "description": "Transform an array by rounding each element to the nearest integer towards zero. The result is an array of floating-point numbers that represent the rounded values.\nParameters:\n- floating_array: An array of floating-point numbers to be rounded.\n- output_container: An optional array to store the rounded values; it must be broadcast-compatible with the input.\nReturns:\n- rounded_array: An array of floats with each element rounded towards zero. If an output container is provided, it will be a reference to this array."
  },
  "numpy.flatnonzero": {
    "new_func": "nonzero_flat_indices",
    "description": "Identify the indices of elements that are non-zero when the input array is flattened to 1-D. The result is a one-dimensional array with the indices corresponding to the non-zero values.\nParameters:\n- input_array: The array whose non-zero elements are to be found.\nReturns:\n- non_zero_indices: An array containing the indices of non-zero elements in the flattened version of the input array."
  },
  "numpy.flatiter": {
    "new_func": "array_linear_traverser",
    "description": "Provides a mechanism to iterate over multi-dimensional arrays as though they are single-dimensional. This iterator can traverse the array in a row-major order and supports both simple and advanced indexing."
  },
  "numpy.fliplr": {
    "new_func": "horizontal_reflect",
    "description": "Creates a view of a two-dimensional or higher array with the order of elements reversed along the second axis. The transformation mimics a horizontal mirror reflection of the array's contents."
  },
  "numpy.float_power": {
    "new_func": "exponential_precision_elevate",
    "description": "Computes the exponentiation of base elements with their corresponding exponents, promoting integers and lower-precision floating points to a higher precision floating point result, ensuring a more accurate output for a wider range of power operations."
  },
  "numpy.floor": {
    "new_func": "integer_downscale",
    "description": "Transforms each element in an array to the largest preceding integer, effectively rounding down in a manner consistent with the mathematical floor function."
  },
  "numpy.floor_divide": {
    "new_func": "integral_quotient",
    "description": "Calculates the quotient of division between corresponding elements in two arrays, rounding towards minus infinity, akin to the integer division operation in Python denoted by //."
  },
  "numpy.fmin": {
    "new_func": "elementary_floor",
    "description": "This function performs a pairwise comparison between elements from two arrays, producing an array with the smallest values. It treats NaN values with special consideration, preferring non-NaN values over NaNs, and defaults to the first element if both are NaNs. Suitable for comparison of complex numbers with NaN components as well. Parameters: - x1 (array_like): First input array. - x2 (array_like): Second input array. They should be broadcastable to the same shape. - out (array, optional): Alternate output array in which to place the result. It must have a shape that the inputs broadcast to. - where (array_like, optional): A boolean array that specifies which elements to compute. The output retains its original value wherever this condition is False. - **kwargs: Additional arguments for more advanced control. Returns: - y (array or scalar): An array with the smallest elements chosen from x1 and x2. A scalar if both x1 and x2 are scalars."
  },
  "numpy.fmax": {
    "new_func": "elementary_ceiling",
    "description": "This function carries out an element-by-element evaluation of two arrays, producing a new array with the greatest values. It effectively ignores NaN values, choosing the numeric value in a pair that includes a NaN. When both values are NaNs, the first is selected. This distinction matters for complex numbers with NaN parts. Parameters: - x1 (array_like): First comparative array. - x2 (array_like): Second comparative array. They must be broadcastable to a common shape. - out (array, optional): Alternative array to store the result. If not specified, a newly-allocated array is returned. - where (array_like, optional): A condition that chooses where to apply the operation. Existing values are preserved where this is False. - **kwargs: Additional keyword arguments for advanced usage. Returns: - y (array or scalar): An array containing the maximum values from x1 and x2 on an element-wise basis. Returns a scalar if both inputs are scalars."
  },
  "numpy.fmod": {
    "new_func": "elemental_remainder",
    "description": "This function computes the remainder on an element-wise basis for two arrays, corresponding to the division of the first array by the second. The sign of the result matches the sign of the dividend. It is similar to the rem function in Matlab and differs from the modulus operator in Python. Parameters: - x1 (array_like): The dividends. - x2 (array_like): The divisors. Arrays should be broadcastable to a common shape. - out (array, optional): Array for output storage. Must broadcast appropriately. If not specified, a new array is created. - where (array_like, optional): Condition array to determine where operation is applied. Unchanged values where condition is False. - **kwargs: Additional keyword-only arguments for detailed configurations. Returns: - y (array_like): The remainder of the division of x1 by x2. Scalar if both inputs are scalars."
  },
  "numpy.format_float_positional": {
    "new_func": "float_to_decimal_string",
    "description": "Transforms a floating-point scalar into a decimal string using positional notation. It allows for precise control over the format, such as rounding, trimming, and padding, utilizing IEEE unbiased rounding and the 'Dragon4' algorithm. Parameters: - x (python float or scalar): The number to format. - precision (int, optional): Maximum number of digits to display. - unique (bool, optional): If True, generates the shortest unique representation of the number. - fractional (bool, optional): Determines if precision refers to digits after the decimal point. - trim (char, optional): Specifies how to trim trailing digits and decimal points. - sign (bool, optional): Indicates whether to display the plus sign for positive values. - pad_left (int, optional): Minimum characters to the left of the decimal point. - pad_right (int, optional): Minimum characters to the right of the decimal point. - min_digits (int, optional): Minimum number of digits to display. Returns: - rep (string): The formatted representation of the floating-point value."
  },
  "numpy.format_float_scientific": {
    "new_func": "float_to_exponential_string",
    "description": "Converts a floating-point scalar to a string in scientific notation. Offers detailed control over rounding, trimming, and padding, with the assumption of IEEE unbiased rounding and the 'Dragon4' algorithm. Parameters: - x (python float or scalar): The number to format. - precision (int, optional): Maximum number of digits to display. - unique (bool, optional): If True, generates the shortest unique numerical representation. - trim (char, optional): Specifies how to trim trailing zeros and decimal points. - sign (bool, optional): Indicates whether to display the plus sign for positive values. - pad_left (int, optional): Minimum characters to the left of the decimal point. - exp_digits (int, optional): Minimum digits in the exponent. - min_digits (int, optional): Minimum number of significant digits to represent the number. Returns: - rep (string): The scientific notation representation of the floating-point value."
  },
  "numpy.frexp": {
    "new_func": "mantissa_exponent_split",
    "description": "Decomposes each element of the input array into its binary significand and corresponding power of two. The result consists of two arrays: one for the normalized significands and another for the integer powers. Each component satisfies the equation: original element = significand * 2^(power).\nParameters:\n- x (array_like): Input values.\n- out1 (array, optional): Placeholder array for the significands.\n- out2 (array, optional): Placeholder array for the powers.\nReturns:\n- significands (array): Normalized floating-point numbers in the range (-1, 1).\n- exponents (array): Integer powers corresponding to the significands."
  },
  "numpy.from_dlpack": {
    "new_func": "tensor_to_array",
    "description": "Converts an object that supports the DLPack data interchange protocol into an array. The resulting array typically provides a read-only view of the data in the original tensor-like object.\nParameters:\n- x (object): An object supporting the __dlpack__ and __dlpack_device__ methods.\nReturns:\n- array (array): The resulting array with data from the input object."
  },
  "numpy.any": {
    "new_func": "elemental_truth_test",
    "description": "Determines if at least one element in the given array evaluates to a truth value over a specified axis.\nParameters:\n- a (array_like): The input to check for truthiness.\n- axis (None or int or tuple of ints, optional): The dimension(s) to perform the logical OR reduction across.\n- out (array, optional): Alternate output array to store the result.\n- keepdims (bool, optional): Whether to maintain reduced dimensions.\n- where (array_like of bool, optional): Condition to filter elements for truthiness check.\nReturns:\n- result (bool or array): A boolean indicating the presence of at least one truthy element, or an array of booleans if the axis is specified."
  },
  "numpy.flipud": {
    "new_func": "vertical_reflection",
    "description": "Flips the entries of an array along the vertical axis, effectively reversing the order of rows.\nParameters:\n- m (array_like): Input array to be flipped.\nReturns:\n- flipped_array (array_like): A view of the input array with rows reversed."
  },
  "numpy.frombuffer": {
    "new_func": "buffer_to_linear_array",
    "description": "Converts a buffer-like object into a 1-dimensional array.\nParameters:\n- buffer (buffer_like): The buffer object to convert.\n- dtype (data-type, optional): Desired data-type for the array, default is float.\n- count (int, optional): Number of items to use from the buffer, default reads all data.\n- offset (int, optional): Initial position in the buffer to start reading from.\nReturns:\n- array (array): An array representation of the buffer content."
  },
  "numpy.fromfunction": {
    "new_func": "array_via_execution",
    "description": "Create an array by applying a provided callable over grid coordinates. The callable receives N-dimensional indices and returns an array element for each coordinate tuple. The dimensions of the resultant array match the supplied shape tuple. Parameters: - callable_function: A callable that accepts N coordinates as arguments. - dimensions: A tuple specifying the dimensions of the output array. - data_type: The desired data type for the coordinates passed to the callable. Default is a floating point. - reference_like: An optional reference object to guide the creation of a compatible array. Returns: An array with elements derived from applying the callable across the coordinate grid."
  },
  "numpy.fromfile": {
    "new_func": "array_from_disk",
    "description": "Create an array by reading from a file, either in text or binary format. This function is especially efficient for reading binary data with a known data structure. Parameters: - source: The file path or object to read from. - data_type: The data type of the array to be returned. - item_count: The number of elements to read, with -1 meaning all elements. - separator: A string defining the separator between elements if the file is text; an empty string indicates binary mode. - byte_offset: Positional byte offset in the file for starting the read operation, applicable to binary files. - reference_like: An optional reference object to guide the creation of a compatible array. Returns: An array constructed from the contents of the file."
  },
  "numpy.fromiter": {
    "new_func": "array_from_iterable",
    "description": "Generate a one-dimensional array from an iterable source. Parameters: - source_iterable: Any iterable yielding data for the array. - data_type: The type of the resulting array elements. - read_count: The number of elements to read from the iterable, with -1 indicating all elements. - reference_like: An optional reference object to guide the creation of a compatible array. Returns: A one-dimensional array with elements obtained from the iterable."
  },
  "numpy.frompyfunc": {
    "new_func": "universal_from_python",
    "description": "Convert a standard Python function into a universal function with broadcasting capabilities. Parameters: - py_function: The Python function to transform. - input_num: The number of inputs the function takes. - output_num: The number of outputs the function produces. - identity_value: Optional value for the identity attribute of the resulting object. Returns: A universal function capable of handling vectorized operations and broadcasting."
  },
  "numpy.fromregex": {
    "new_func": "structured_array_via_pattern",
    "description": "Parse a text file using a regular expression and return a structured array based on the matches found. Parameters: - source_file: The file path or object from which to read. - pattern: A regular expression with groups corresponding to the fields of the structured data type. - structured_type: The data type for the array, which must be a structured type with fields corresponding to the regular expression groups. - text_encoding: Optional text encoding for decoding the input file. Returns: A structured array containing the parsed data from the file."
  },
  "numpy.copysign": {
    "new_func": "match_magnitude_direction",
    "description": "Alter the magnitude signs to align with the direction of another set of values, for each pair of corresponding elements. If the directional source is a single value, its sign is replicated across all magnitude elements. Parameters: - magnitude_values (array_like): Values for which the signs are to be modified. - direction_source (array_like): Values providing the desired sign. - out (array, optional): Alternate output array to store the results. Default is None. - where (array_like, optional): Condition array that selects which entries to modify. Returns: - result (array or scalar): The magnitude values with altered signs matching the direction source."
  },
  "numpy.fromstring": {
    "new_func": "text_to_array",
    "description": "Creates a 1-dimensional array from numerical data contained in a text string, interpreting the data according to the specified format. Parameters: - input_text (str): The string holding the numerical data. - element_type (data-type, optional): Expected type of array elements. Default is float. - element_count (int, optional): The number of elements to parse and include in the array. Default reads all. - delimiter (str, optional): Separator between numbers in the input text. Returns: - formed_array (array): The array generated from the text data."
  },
  "numpy.full": {
    "new_func": "populate_uniformly",
    "description": "Produces an array with a specified shape, filled uniformly with the provided value. Parameters: - dimensions (int or sequence of ints): The shape of the resulting array. - uniform_value (scalar or array_like): The value to fill the array with. - element_type (data-type, optional): Desired data-type for the array. Defaults to the type of uniform_value. - memory_order ({'C', 'F'}, optional): Memory storage order of the array. Returns: - filled_array (array): An array with the specified dimensions filled with uniform_value."
  },
  "numpy.gcd": {
    "new_func": "maximum_common_divisor",
    "description": "Determines the largest integer that exactly divides each pair of corresponding elements from two arrays. Parameters: - values1 (array_like, int): First array of integers. - values2 (array_like, int): Second array of integers. Returns: - divisors (array or scalar): The largest common divisors for each pair of elements from the input arrays."
  },
  "numpy.full_like": {
    "new_func": "replicate_structure",
    "description": "Generates a new array matching the structure and data type of an existing array, but filled entirely with a specified value. Parameters: - template_array (array_like): The reference array whose shape and data-type guide the creation. - fill_value (array_like): The value to populate the new array with. - element_type (data-type, optional): Overrides the data type of the result. - memory_order ({'C', 'F', 'A', 'K'}, optional): Memory storage order of the result. - preserve_subtype (bool, optional): If True, the new array will be the same subclass as template_array, otherwise it will be a base-class array. - new_dimensions (int or sequence of ints, optional): The shape of the result, overriding that of the template. Returns: - replicated_array (array): The new array with the specified fill value and structure similar to the template_array."
  },
  "numpy.busday_offset": {
    "new_func": "weekday_shifter",
    "description": "Shifts the provided dates by the given number of valid weekdays. Adjusts for specified rolling conventions and considers custom weekly schedules and holiday calendars. Parameters: - dates: array_like of datetime64[D], The array of dates to adjust. - offsets: array_like of int, Offsets to apply to the dates, with positive or negative values to shift forwards or backwards. - roll: string, optional, Defines the adjustment strategy for non-business days. Options include adjustments to the nearest valid day before or after, or returning error or NaT, among others. - weekmask: string or array_like of bool, optional, Defines the valid weekdays with a length-seven pattern for Monday through Sunday. - holidays: array_like of datetime64[D], optional, Dates to be considered as non-business days. - busdaycal: busdaycalendar, optional, A custom business day calendar that predefines valid days. - out: array of datetime64[D], optional, An output array to store the result. Returns: - out: array of datetime64[D], An array of adjusted dates."
  },
  "numpy.genfromtxt": {
    "new_func": "text_to_array",
    "description": "Loads and decodes data from a text file, with configurable delimiters, comments, and missing value handling. Converts the text to a structured array based on the specified data types. Parameters: - fname: filepath or object, Source of the input data. - dtype: dtype, optional, Data type of the resulting array, with columns determined individually if unspecified. - comments: string, optional, Character to mark the start of a comment. - delimiter: string or int, optional, Character or field width to separate data values. - skip_header: int, optional, Number of lines at the file start to ignore. - skip_footer: int, optional, Number of lines at the file end to skip. - converters: dict, optional, Functions to convert or provide defaults for data in each column. - missing_values: dict, optional, Strings that represent missing data. - filling_values: dict, optional, Default values to fill in for missing data. - usecols: sequence, optional, Indices of columns to read. - names: sequence or bool, optional, Field names to use, with auto-detection if set to True. - replace_space: char, optional, Replacement for spaces in field names. - unpack: bool, optional, If True, transposes the array to unpack into variables. - usemask: bool, optional, If True, returns a masked array where missing values are masked. - max_rows: int,  optional, Maximum number of rows to read. - encoding: string, optional, Encoding to decode the input. Returns: - out: array or MaskedArray, The array constructed from the textual data."
  },
  "numpy.get_include": {
    "new_func": "header_directory",
    "description": "Provides the directory path that contains the header files for extension modules compiling against this library. Essential for locating the necessary headers to build native extensions. Returns: - path: string, The directory path containing the header files."
  },
  "numpy.get_printoptions": {
    "new_func": "display_preferences",
    "description": "Retrieves the current configuration for displaying arrays, including options for precision, line width, and threshold among others. Returns: - options: dict, A dictionary containing the current settings that dictate array display format."
  },
  "numpy.geomspace": {
    "new_func": "logarithmic_progression",
    "description": "Generates a sequence of numbers spaced according to a geometric series, which is useful for creating a log-scale distribution. Provides an alternative to arithmetic spacing. Parameters: - start: array_like, The first value of the sequence. - stop: array_like, The last value of the sequence, if endpoint is included. - num: int, optional, The total count of numbers to generate. - endpoint: bool, optional, Determines whether to include the stop value in the output. - dtype: dtype, The desired data type of the output array. - axis: int, optional, The axis along which the numbers are generated in the output array. Returns: - samples: array, A sequence where each element is multiplied by a constant factor to achieve a logarithmic scale."
  },
  "numpy.geterr": {
    "new_func": "float_exception_handling",
    "description": "Retrieve the current strategy for managing errors during floating-point operations. Returns a dictionary with keys corresponding to different error types such as 'divide', 'over', 'under', and 'invalid', with associated values indicating the response to these errors, such as 'ignore', 'print', 'log', 'warn', 'raise', or 'call'. These responses dictate the behavior when an error occurs."
  },
  "numpy.getbufsize": {
    "new_func": "universal_function_buffer_dimension",
    "description": "Acquire the dimension of the internal buffer utilized by universal functions, measured in bytes. The buffer size determines how much data is processed at a time during the execution of these functions."
  },
  "numpy.cumprod": {
    "new_func": "sequential_multiplication",
    "description": "Calculate the sequential product of array elements across a specified dimension. The function accepts an input array and returns an array of the same shape containing the cumulative products. If no dimension is specified, the input is flattened before computation. The data type of the output array can be specified, and an alternate destination array for the results can be provided."
  },
  "numpy.cumsum": {
    "new_func": "sequential_addition",
    "description": "Compute the running total of array elements along a specified dimension. The function takes an input array and produces an array of the same size with the accumulated sums. If no dimension is given, the operation is performed on the flattened array. An optional data type for the output and an alternative destination for the result can be dictated."
  },
  "numpy.geterrcall": {
    "new_func": "float_error_callback_retriever",
    "description": "Obtain the currently set callback function or logging instance that is activated upon encountering a floating-point error. The types of errors include 'divide', 'over', 'under', or 'invalid'. If the error management is configured to 'call' or 'log', this function or logging instance is fetched, which was previously established using a corresponding setup function. If no function or instance has been set, the return value is None."
  },
  "numpy.gradient": {
    "new_func": "multi_dimensional_differences",
    "description": "Calculate the numerical derivative along each dimension of a multi-dimensional array. The derivatives are computed using central differences with a second-order accuracy for interior data points and either first or second-order one-sided differences at the boundaries. The result has the same shape as the input array.\nParameters:\n- f: array_like, An array of scalar function samples.\n- varargs: list, Optional spacings between f values. Defaults to unitary spacing for all dimensions.\n- edge_order: {1, 2}, Order of the differences at the boundaries.\n- axis: None or int or tuple of ints, Axes along which the derivative is calculated. Defaults to all axes.\nReturns:\n- gradient: array or list of array, The derivatives with respect to each dimension."
  },
  "numpy.greater": {
    "new_func": "element_wise_superiority",
    "description": "Determine the element-wise superiority of two arrays, producing a boolean array that is True where the first array's elements are superior to those of the second array.\nParameters:\n- x1, x2: array_like, Input arrays to compare.\n- out: array, optional, Output array with the result.\n- where: array_like, optional, Condition over which to perform the comparison.\nReturns:\n- out: array of booleans, The comparison's outcome."
  },
  "numpy.degrees": {
    "new_func": "radians_to_angle_units",
    "description": "Transform an array of angles from radians to angle units.\nParameters:\n- x: array_like, Angles in radians.\n- out: array, optional, Output array for the angle units.\n- where: array_like, optional, Condition over which to transform.\nReturns:\n- y: array of floats, The angles in angle units."
  },
  "numpy.hamming": {
    "new_func": "cosine_taper_window",
    "description": "Generate a symmetric window used for signal processing with a shape defined by a weighted cosine function.\nParameters:\n- M: int, Number of points in the output window. If less than one, returns an empty array.\nReturns:\n- out: array, The generated window with values normalized to one at its peak."
  },
  "numpy.greater_equal": {
    "new_func": "element_wise_noninferiority",
    "description": "Assess the element-wise noninferiority of two arrays, yielding a boolean array that is True where the elements of the first array are noninferior to those of the second array.\nParameters:\n- x1, x2: array_like, Input arrays for comparison.\n- out: array, optional, Container for the outcome.\n- where: array_like, optional, Mask that defines where to apply the comparison.\nReturns:\n- out: bool or array of bool, Result of the element-wise comparison."
  },
  "numpy.hanning": {
    "new_func": "cosine_window",
    "description": "Returns a symmetric window with a raised-cosine shape. This window is often used in signal processing to minimize the nearest side lobe.\nParameters:\n- points: int, The number of points in the generated window. Returns an empty array for non-positive values.\nReturns:\n- window_array: array, A 1-D array containing the raised-cosine window values, normalized so that the maximum value is one. The maximum value occurs at the center of the window (for odd-sized windows)."
  },
  "numpy.histogram_bin_edges": {
    "new_func": "bin_boundary_calculator",
    "description": "Computes the boundaries of bins for histogramming the data.\nParameters:\n- data: array_like, Input data to be binned.\n- bin_spec: int, sequence of scalars, or string, Defines the number or the edges of bins, or a method for optimal calculation of bin width.\n- span: tuple of floats (optional), Defines the lower and upper range of the bins. If not specified, the minimum and maximum values of the data are used.\n- sample_weights: array_like (optional), Weights for each data point. Currently not used for automatic bin calculation.\nReturns:\n- edges: array, An array of bin edges for passing to a histogram function."
  },
  "numpy.histogram2d": {
    "new_func": "bi_dimensional_frequency",
    "description": "Calculates a two-dimensional histogram for a set of data points.\nParameters:\n- x_coords: array_like, X-coordinates of the data points.\n- y_coords: array_like, Y-coordinates of the data points.\n- bin_spec: int, array_like, or a list of two, Defines the bin specification for both dimensions.\n- span: array_like (optional), The bin range for each dimension.\n- normalize: bool (optional), Whether to return the number of samples or the probability density function.\n- sample_weights: array_like (optional), Weights for each data point.\nReturns:\n- histogram: array, A 2D array where elements are the counts or probability density in each bin.\n- x_edges: array, The bin edges along the first dimension.\n- y_edges: array, The bin edges along the second dimension."
  },
  "numpy.histogramdd": {
    "new_func": "multi_dimensional_frequency",
    "description": "Computes a histogram over multiple dimensions for a dataset.\nParameters:\n- samples: (N, D) array or array_like, Input data to be histogrammed.\n- bins_spec: sequence or int (optional), Specifies the number or the edges of the bins for each dimension.\n- range_seq: sequence (optional), Specifies the bin range for each dimension.\n- density_option: bool (optional), If true, results in a probability density function, otherwise counts the number of samples per bin.\n- weights: array_like (optional), Weights for each sample point.\nReturns:\n- histogram: array, A D-dimensional array of binned sample counts or probability density.\n- edges: tuple of arrays, Bin edges for each dimension."
  },
  "numpy.histogram": {
    "new_func": "data_distribution",
    "description": "Computes the distribution of input data across specified bins.\nParameters:\n- input_data: array_like, The data to be binned.\n- bin_count_or_edges: int, sequence, or string (optional), Defines the total bins or specific bin edges, or a string for an automatic method of computing bin width.\n- range_limits: tuple of floats (optional), The lower and upper range of the bins.\n- weight_values: array_like (optional), Weights associated with the input data.\n- density_value: bool (optional), If true, returns the probability density function; otherwise, returns the bin counts.\nReturns:\n- distribution: array, A 1-D array of the histogram counts or densities.\n- bin_edges: array, 1-D array of bin boundaries."
  },
  "numpy.hsplit": {
    "new_func": "divide_columns",
    "description": "Divide an array into multiple sub-arrays along the vertical axis. For 2-D or higher arrays, this operation is performed along the second axis. For 1-D arrays, the division occurs along the first axis. This function is useful for splitting an array into several smaller arrays of specified indices or sections.\nParameters:\n- ary: array_like, The array to be divided.\n- indices_or_sections: int or 1-D array, If an integer, the array will be divided into that many equally shaped arrays. If a 1-D array of sorted integers, the entries indicate where along the axis the array is split.\nReturns:\n- sub_arrays: list of arrays, A list of sub-arrays as views into ary."
  },
  "numpy.hstack": {
    "new_func": "merge_columns",
    "description": "Combine arrays in sequence along the vertical axis. This function is well-suited for arrays with up to three dimensions, such as combining pixel-data with separate color channels. It is also the inverse operation of 'divide_columns' for rebuilding arrays.\nParameters:\n- tup: sequence of array_like, The arrays must have the same shape along all but the second axis. 1-D arrays can be of any length.\n- dtype: str or dtype, optional, The desired data-type for the output array.\n- casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional, Controls what kind of data casting may occur.\nReturns:\n- merged: array, The array resulting from the combination of the input arrays."
  },
  "numpy.identity": {
    "new_func": "unit_matrix",
    "description": "Generate a square array with ones on the main diagonal and zeros elsewhere.\nParameters:\n- n: int, The number of rows and columns in the output square array.\n- dtype: data-type, optional, The desired data-type for the output array.\n- like: array_like, optional, Reference object for array creation compatibility.\nReturns:\n- out: array, A square array with its main diagonal filled with ones and all other elements set to zero."
  },
  "numpy.i0": {
    "new_func": "bessel_zero_order",
    "description": "Compute the modified Bessel function of the first kind and zero order for each element in the input array. It is often used in signal processing and other applied mathematics fields.\nParameters:\n- x: array_like of float, The input values for which the Bessel function should be evaluated.\nReturns:\n- out: array, The values of the modified Bessel function for each input value, having the same shape and data type as the input."
  },
  "numpy.hypot": {
    "new_func": "right_triangle_hypotenuse",
    "description": "Calculate the length of the hypotenuse of a right-angled triangle for given 'legs' of the triangle, working element-wise. This function is equivalent to the square root of the sum of squares of the legs.\nParameters:\n- x1, x2: array_like, The 'legs' of the triangle(s).\n- out: array, optional, A location into which the result is stored.\n- where: array_like, optional, Condition array that chooses where the operation should be applied.\nReturns:\n- z: array, The hypotenuse of the triangle(s). The shape of the output array is the broadcasted shape of x1 and x2."
  },
  "numpy.heaviside": {
    "new_func": "unit_step",
    "description": "Calculate the unit step function, which is zero for negative input, one for positive input, and an arbitrary value (commonly 0.5) for zero input. Parameters: - x1 (array_like): Input values. - x2 (array_like): The function's value when input is zero. If the shapes of x1 and x2 differ, they must be broadcastable to a shared shape. - out (array, optional): A location into which the result is stored. - where (array_like, optional): A boolean array that specifies where to apply the function. Returns: - out (array or scalar): The calculated step function for each element in x1."
  },
  "numpy.imag": {
    "new_func": "imaginary_part",
    "description": "Retrieve the imaginary component of a complex argument. Parameters: - val (array_like): Input array. Returns: - out (array or scalar): The imaginary part of the input. If the input is real, the output type is the same as the input type. If the input has complex elements, the output type is float."
  },
  "numpy.in1d": {
    "new_func": "element_membership",
    "description": "Determine the presence of elements of the first 1-D array in a second array, returning a boolean array of the same length. Parameters: - ar1 (array_like): Input array. - ar2 (array_like): The values to compare against. - assume_unique (bool, optional): Optimizes computation if both arrays are known to be unique. - invert (bool, optional): If True, inverts the returned boolean values. - kind ({None, 'sort', 'table'}, optional): Algorithm choice may affect performance and memory usage. Returns: - result (array): Boolean array indicating the presence of ar1 elements in ar2."
  },
  "numpy.indices": {
    "new_func": "grid_indices",
    "description": "Generate a grid of indices with the specified shape. Parameters: - dimensions (sequence of ints): The grid's shape. - dtype (dtype, optional): Desired output data type. - sparse (bool, optional): If True, returns a sparse representation of the grid. Returns: - grid (array or tuple of arrays): If sparse is False, returns one array of indices. If sparse is True, returns a tuple of arrays, each containing indices along one axis."
  },
  "numpy.info": {
    "new_func": "object_insight",
    "description": "Provide detailed information about an object, such as an array or function. If no object is provided, information about the function itself is returned. Parameters: - object (object or str, optional): Target object or name. - maxwidth (int, optional): Maximum width for printing. - output (file-like object, optional): Destination for output, defaults to standard output. - toplevel (str, optional): Starting point for the search. Returns: Information is printed to the output or standard output; no values are returned."
  },
  "numpy.inner": {
    "new_func": "multidimensional_product",
    "description": "Calculate the sum product over the last axes of two input arrays. For one-dimensional arrays, it computes the sum of products of the arrays. If either array is higher-dimensional, the product sums over the last axis of each array. For scalar inputs, it multiplies the two values directly.\nParameters:\n- a (array_like): First input array.\n- b (array_like): Second input array, with the same size as the last dimension of 'a'.\nReturns:\n- out (array): The product, with the shape determined by removing the last axis of each input and concatenating the remaining axes.\n- Raises ValueError if the last dimensions of the arrays do not match."
  },
  "numpy.iinfo": {
    "new_func": "integer_limits",
    "description": "Provides the storage limits of integer data types.\nParameters:\n- int_type (integer type, dtype, or instance): Specifies the integer type to retrieve limits for.\nReturns:\n- An object with the following attributes:\n  - min (int): The smallest representable number of the data type.\n  - max (int): The largest representable number of the data type.\n  - bits (int): The number of bits used to store the data type.\n  - dtype (dtype): The specific data type for which information is provided."
  },
  "numpy.insert": {
    "new_func": "array_augment",
    "description": "Introduce new elements into an array before specified indices.\nParameters:\n- arr (array_like): The target array to augment.\n- obj (int, slice, or sequence of ints): The index or indices before which the new values are to be inserted.\n- values (array_like): The values to be inserted into 'arr'. Should be shaped to match 'arr'.\n- axis (int, optional): The axis along which to insert 'values'. If None, the array will be flattened first.\nReturns:\n- out (array): A new array with 'values' inserted at 'obj' positions. If 'axis' is None, 'out' will be a flattened array."
  },
  "numpy.intersect1d": {
    "new_func": "common_elements",
    "description": "Identifies the sorted, unique elements common to both input arrays.\nParameters:\n- ar1, ar2 (array_like): Input arrays to compare. They will be flattened if not already one-dimensional.\n- assume_unique (bool): When True, the inputs are assumed to be unique, which can speed up the computation. Defaults to False.\n- return_indices (bool): If True, returns the indices of the common elements in both arrays. Defaults to False.\nReturns:\n- intersect1d (array): The sorted unique values common to both arrays.\n- comm1 (array): Indices of common values in 'ar1'. Only provided if 'return_indices' is True.\n- comm2 (array): Indices of common values in 'ar2'. Only provided if 'return_indices' is True."
  },
  "numpy.interp": {
    "new_func": "piecewise_linear_approximation",
    "description": "Performs piecewise linear interpolation on one-dimensional data. Given discrete data points, this function estimates intermediate values by linear approximation.\nParameters:\n- x (array_like): The x-coordinates for which to interpolate values.\n- xp (1-D sequence of floats): The increasing x-coordinates of the data points.\n- fp (1-D sequence of floats or complex): The y-coordinates of the data points, same length as 'xp'.\n- left (optional): Value to return for 'x' less than 'xp[0]', defaults to 'fp[0]'.\n- right (optional): Value to return for 'x' greater than 'xp[-1]', defaults to 'fp[-1]'.\n- period (None or float, optional): Period for the x-coordinates, enabling interpolation of angular coordinates.\nReturns:\n- y (float, complex, or array): Interpolated values, with the same shape as 'x'."
  },
  "numpy.isdtype": {
    "new_func": "type_compliance_check",
    "description": "Assesses if the provided data type specification conforms to a specified category of data types. This method is limited to built-in data type categories and does not accommodate third-party or custom data types. Parameters: - input_dtype: The data type to test. - category: A data type category or a string or tuple representing such categories. Acceptable categories include representations of boolean, signed/unsigned integers, floating-point, and complex data types among others. Returns: - result: A boolean value indicating whether the input_dtype matches the specified category."
  },
  "numpy.isfinite": {
    "new_func": "check_finiteness",
    "description": "Evaluates each element of the provided array to determine whether it is finite (i.e., not infinity and not 'Not a Number'). The outcome is an array of booleans corresponding to the input shape. Parameters: - input_array: Values to be evaluated. - destination: Optional output array to store the results. - condition: Optional condition to apply element-wise to the input. - additional_args: Other arguments affecting behavior as per ufunc documentation. Returns: - finite_flags: An array indicating with 'True' the elements that are finite, and 'False' otherwise."
  },
  "numpy.isfortran": {
    "new_func": "fortran_style_check",
    "description": "Determines if an array is stored in memory following Fortran-order conventions, excluding arrays that are also C-contiguous. Users should use the array's flags.f_contiguous attribute directly for this purpose as this function is outdated. Parameters: - input_array: The array to evaluate. Returns: - fortran_contiguous: A boolean indicating whether the array is stored in Fortran-contiguous order without being C-contiguous."
  },
  "numpy.isnan": {
    "new_func": "detect_nan_values",
    "description": "Performs an element-wise test on the provided array to identify 'Not a Number' (NaN) values, returning the results in a boolean array. Parameters: - input_array: Array to inspect for NaN values. - destination: Optional array to store the results. - condition: Optional condition to apply element-wise to the input. - additional_args: Other arguments based on the ufunc documentation. Returns: - nan_flags: An array where each 'True' entry indicates a NaN in the corresponding position of the input array."
  },
  "numpy.isin": {
    "new_func": "element_membership_test",
    "description": "Evaluates whether each element in a given array exists within a set of specified elements, returning a boolean array of the same shape. Parameters: - test_array: Array of elements to check for presence. - reference_elements: Array of elements to compare against. - unique_assumption: Optional flag to assume uniqueness in arrays for faster computation. - negation: Optional flag to invert the results. - algorithm_hint: Algorithm choice for computation, with options affecting speed and memory. Returns: - membership_result: A boolean array indicating the presence of test_array elements in reference_elements."
  },
  "numpy.isinf": {
    "new_func": "detect_infinite",
    "description": "Determines whether each element in the input array is either positive or negative infinity and returns a boolean array of the same shape indicating the result. Parameters: - input_values (array_like): The values to check for infinity. - destination (array, optional): An array to store the results. If not specified, a new array is allocated. - condition (array_like, optional): A boolean array that determines where the function is applied. If False, the corresponding position in the destination is left unchanged. Returns: - result (array or bool): An array with boolean values indicating the presence of infinite values in the input array. True for infinite values, False otherwise. This will be a single boolean value if the input is a scalar."
  },
  "numpy.isnat": {
    "new_func": "detect_not_a_time",
    "description": "Evaluates each element in the input array to check if it represents a 'Not a Time' (NaT) value and returns a boolean array with the results. Parameters: - input_array (array_like): Array with datetime or timedelta data type to check for NaT values. - destination (array, optional): An array to store the results. If omitted, a new array is created. - condition (array_like, optional): A boolean mask that determines where to apply the function. If False, the corresponding location in the destination retains its original value. Returns: - result (array or bool): An array of booleans, with True indicating NaT values. For scalar inputs, the result is a single boolean value."
  },
  "numpy.isneginf": {
    "new_func": "detect_negative_infinity",
    "description": "Identifies whether each element in the input array is negative infinity, producing a boolean array that indicates the findings. Parameters: - input_values (array_like): The array to be checked for negative infinity. - destination (array_like, optional): An array to store the results. A new boolean array is created if this parameter is not provided. Returns: - result (array): An array of boolean values, where True corresponds to elements in the input that are negative infinity."
  },
  "numpy.isposinf": {
    "new_func": "detect_positive_infinity",
    "description": "Assesses each element in the input array for positive infinity and outputs a boolean array reflecting the determination. Parameters: - input_values (array_like): The array under examination for positive infinity. - destination (array_like, optional): A pre-allocated array to hold the results. If omitted, a new boolean array is generated. Returns: - result (array): A boolean array with True for elements that are positive infinity and False elsewhere."
  },
  "numpy.isreal": {
    "new_func": "detect_real_numbers",
    "description": "Checks if each element in the input array is a real number, which includes complex numbers with an imaginary part of zero, and returns a boolean array indicating the outcome. Parameters: - input_values (array_like): The array to be checked for real numbers. Returns: - result (array, bool): A boolean array with the same shape as the input, where True indicates that the element is a real number."
  },
  "numpy.isrealobj": {
    "new_func": "noncomplex_verifier",
    "description": "Determines if the input is non-complex or does not consist of complex numbers. This method evaluates the data type rather than the value; inputs with zero imaginary part are still considered complex if their data type is complex.\nParameters:\n- input: The input to check, accepts any type or shape.\nReturns:\n- result: A boolean indicating whether the input is non-complex (True) or complex (False)."
  },
  "numpy.isscalar": {
    "new_func": "single_value_checker",
    "description": "Evaluates whether the provided element is a single-value data type. This method checks the type but not the dimensions of the element.\nParameters:\n- element: The item to assess, can be of any type.\nReturns:\n- is_single_value: A boolean indicating if the element is a single-value data type (True) or not (False)."
  },
  "numpy.issubdtype": {
    "new_func": "subtype_evaluator",
    "description": "Checks if one data type is a subtype or equal to another in the type hierarchy, similar to checking class inheritance.\nParameters:\n- arg1: The data type to check.\n- arg2: The reference data type for comparison.\nReturns:\n- is_subtype: A boolean indicating if arg1 is a subtype of arg2."
  },
  "numpy.iterable": {
    "new_func": "iteration_capability_inspector",
    "description": "Assesses if an object can be iterated over, checking for an iteration method or if it is a sequence type.\nParameters:\n- object: The object to examine for iteration capability.\nReturns:\n- can_iterate: A boolean indicating if the object is iterable."
  },
  "numpy.kaiser": {
    "new_func": "bessel_taper_window_generator",
    "description": "Generates a tapering window using a zeroth-order modified Bessel function, with parameters controlling the number of points and the shape of the taper.\nParameters:\n- points_count: The number of points in the generated window.\n- shape_param: The parameter that influences the shape of the window.\nReturns:\n- window_values: An array representing the window, with the highest value normalized to one."
  },
  "numpy.kron": {
    "new_func": "tensor_expansion",
    "description": "Calculates the tensor expansion of two arrays, generating an array made up of blocks of the second array scaled by the elements of the first. Parameters: - a (array_like): The scaling array. - b (array_like): The array to be replicated and scaled. Returns: - out (array): The resulting array with shape determined by multiplying the dimensions of a and b."
  },
  "numpy.lcm": {
    "new_func": "minimal_multiple",
    "description": "Determines the smallest shared multiple of two integers or arrays of integers. Parameters: - x1 (array_like, int): First input values. - x2 (array_like, int): Second input values, must be broadcastable to the shape of x1. Returns: - y (array or scalar): The minimum common multiple of the absolute values of the inputs, shared shape if inputs are arrays, or scalar if inputs are integers."
  },
  "numpy.astype": {
    "new_func": "type_transformer",
    "description": "Transforms the data type of an array to the specified type. Parameters: - x (array): The array to cast. - dtype (dtype): The target data type. - copy (bool, optional): If True, always returns a copy. If False, returns the original array if the dtype is unchanged. Defaults to True. Returns: - out (array): Array with the new data type."
  },
  "numpy.atleast_3d": {
    "new_func": "ensure_tridimensional",
    "description": "Converts one or more input arrays to arrays with at least three dimensions. Parameters: - arys1, arys2, ... (array_like): Input sequences to be converted to arrays with a minimum of three dimensions. Returns: - res1, res2, ... (array): The modified arrays, each with at least three dimensions. Existing arrays with three or more dimensions are returned unchanged."
  },
  "numpy.average": {
    "new_func": "weighted_mean",
    "description": "Calculates the mean of an array's elements, potentially weighted by another array. Parameters: - a (array_like): Data to compute the mean of. - axis (None, int, or tuple of ints, optional): Axis along which to average. - weights (array_like, optional): Weights for each element in a. - returned (bool, optional): If True, returns a tuple with the mean and sum of weights. Defaults to False. - keepdims (bool, optional): If True, keeps reduced axes with size one. Returns: - retval (array_type or double): The averaged data. A tuple (average, sum_of_weights) if returned is True."
  },
  "numpy.left_shift": {
    "new_func": "bitwise_augment_left",
    "description": "Perform a binary shift towards the higher order bits of an integer, effectively multiplying the number by a power of two for each shift. Parameters: - multiplicand (array_like of integer type): The initial integers. - shift_count (array_like of integer type): The number of bit positions to shift. Must be non-negative. Both arguments must be broadcastable to a common shape. - destination (array, None, or tuple of array and None, optional): The array to store the results in. If not provided, a new array is created. - condition (array_like, optional): A boolean array that specifies where to apply the operation. Returns: - result (array of integer type): The integers after shifting the bits to the left by the specified counts."
  },
  "numpy.ix_": {
    "new_func": "open_meshgrid",
    "description": "Create a set of multidimensional grids where each grid has one dimension's size equal to the corresponding input sequence size and the rest set to 1. These grids can be used to index into a multi-dimensional array for broadcasting operations. Parameters: - sequences (1-D sequences of int or bool): Integer sequences create grid indices, while boolean sequences are treated as boolean masks. Returns: - grid_tuple (tuple of arrays): A tuple of N arrays, each with N dimensions, where N is the number of input sequences."
  },
  "numpy.ldexp": {
    "new_func": "mantissa_exponent_combiner",
    "description": "Construct floating-point numbers from arrays of mantissas and corresponding exponent values, multiplying each mantissa by two raised to its associated exponent. Parameters: - mantissas (array_like): The coefficients for the calculation. - exponents (array_like, int): The powers of two to multiply the mantissas by. The shapes must be compatible for broadcasting. - destination (array, None, or tuple of array and None, optional): The array to store the results in. If not provided, a new array is created. Returns: - combined_values (array or scalar): The resulting floating-point numbers, element-wise from the inputs."
  },
  "numpy.less": {
    "new_func": "elementwise_comparator_lt",
    "description": "Determine the element-wise less-than relationship between two arrays. Parameters: - first_operand (array_like): First input array. - second_operand (array_like): Second input array to compare against the first. - destination (array, None, or tuple of array and None, optional): The array to store the results in. If not provided, a new array is created. Returns: - comparison_result (array or scalar): An array of boolean values indicating the result of the comparison."
  },
  "numpy.less_equal": {
    "new_func": "elementwise_comparator_lte",
    "description": "Evaluate whether elements in the first input array are less than or equal to those in the second array on an element-wise basis. Parameters: - first_operand (array_like): First input array. - second_operand (array_like): Second input array to be compared against the first. - destination (array, None, or tuple of array and None, optional): The array to store the results in. If not provided, a new array is created. Returns: - comparison_result (array or scalar): An array of booleans indicating whether elements of the first array are less than or equal to those of the second array."
  },
  "numpy.linspace": {
    "new_func": "uniform_sequence",
    "description": "Generate a sequence of values evenly distributed over a defined interval. Parameters: - start: array_like, Initial value of the sequence. - stop: array_like, Final value of the sequence, optionally excluded. - num: int, optional, Amount of values to produce. A positive number, defaults to 50. - endpoint: bool, optional, Whether to include the stop value in the sequence. Default is True. - retstep: bool, optional, Whether to return the step size between values. - dtype: dtype, optional, Data type of the output array. Inferred if not provided. - axis: int, optional, Axis along which values are stored in the output array. - device: str, optional, Device where the array is to be placed. Returns: - samples: array, Sequence of evenly distributed values. - step: float, optional, Interval between values, returned if retstep is True."
  },
  "numpy.lexsort": {
    "new_func": "indirect_stable_sequence_sort",
    "description": "Arrange data using a sequence of sorting keys. The last key is the primary sort order, followed by the second last, and so on. Parameters: - keys: (k, m, n, ...) array-like, Sequence of keys for sorting. - axis: int, optional, Axis along which to sort. Default is the last axis. Returns: - indices: array of ints, Index array arranging the keys into sorted order."
  },
  "numpy.loadtxt": {
    "new_func": "text_to_array",
    "description": "Read and convert data from a text file into an array. Parameters: - fname: file, str, pathlib.Path, list of str, or generator, Source of the input data. - dtype: data-type, optional, Desired data-type for the array, default is float. - comments: str or sequence of str or None, optional, Character or characters to mark the beginning of a comment, default is '#'. - delimiter: str, optional, String to separate values, default is any whitespace. - converters: dict or callable, optional, Functions to convert values, default is None. - skiprows: int, optional, Number of lines to skip at the beginning. - usecols: int or sequence, optional, Columns to read, with 0 as the first. - unpack: bool, optional, If True, the returned array is transposed. - ndmin: int, optional, Minimum number of dimensions of the output. - encoding: str, optional, Encoding of the input file. - max_rows: int, optional, Maximum number of rows to read. - quotechar: unicode character or None, optional, Character to denote start and end of a quoted item. Returns: - out: array, Array of data from the text file."
  },
  "numpy.log10": {
    "new_func": "decadic_logarithm",
    "description": "Compute the common (base 10) logarithm for each element of the input array. Parameters: - x: array_like, Input values. - out: array, optional, Alternative output array in which to place the calculation. - where: array_like, optional, Condition array that chooses where the function is applied. - **kwargs: Additional keyword arguments for advanced use. Returns: - y: array, The base 10 log values of the input array."
  },
  "numpy.log1p": {
    "new_func": "incremental_logarithm",
    "description": "Calculate the natural logarithm of 1 plus each element in the input array. Parameters: - x: array_like, Input values. - out: array, optional, Alternative output array for the results. - where: array_like, optional, Condition array to choose where the function is applied. - **kwargs: Additional keyword arguments for advanced use. Returns: - y: array, Logarithmic values of 1 plus the input array elements."
  },
  "numpy.log": {
    "new_func": "natural_antilogarithm",
    "description": "Compute the inverse exponential function of the input array, element by element. The function computes the base e logarithm.\nParameters:\n- x (array_like): Input array.\n- out (array, optional): Alternative output array in which to place the calculation. It must have the same shape as the input array.\n- where (array_like, optional): A boolean array that specifies where the calculations are to be performed.\n- **kwargs: Additional arguments for advanced usage.\nReturns:\n- y (array): The base e logarithm of the input array, computed element-wise."
  },
  "numpy.load": {
    "new_func": "retrieve_array",
    "description": "Reads and returns the contents of a binary file in the form of an array or a collection of arrays. Can read files saved in .npy, .npz formats, as well as pickled files.\nParameters:\n- file (file-like object or string): The file from which to read.\n- mmap_mode (optional): Memory-mapping mode for reading large files.\n- allow_pickle (bool, optional): Whether to allow loading pickled object arrays.\n- fix_imports (bool, optional): Fixes import errors when loading Python 2 pickled files in Python 3.\n- encoding (str, optional): Encoding to use for loading Python 2 strings.\n- max_header_size (int, optional): Maximum size of header to allow for secure loading.\nReturns:\n- result: Data read from the file, which could be an array, tuple, or dictionary."
  },
  "numpy.log2": {
    "new_func": "binary_antilogarithm",
    "description": "Calculates the base-2 logarithm for each element in the input array.\nParameters:\n- x (array_like): Values for which the logarithm is calculated.\n- out (array, optional): An alternative output object to store the result.\n- where (array_like, optional): A conditional array indicating where the calculation should be performed.\n- **kwargs: Additional keyword arguments for advanced usage.\nReturns:\n- y (array): The base-2 logarithm of the input values."
  },
  "numpy.logaddexp": {
    "new_func": "exponential_sum_logarithm",
    "description": "Computes the logarithm of the sum of exponentials of two arrays, element-wise. It is useful for computing log-domain calculations to avoid underflow or overflow.\nParameters:\n- x1, x2 (array_like): Input arrays for which the log sum exp is calculated.\n- out (array, optional): An alternative output object to store the results.\n- where (array_like, optional): A conditional array indicating where the operation should be performed.\n- **kwargs: Additional keyword arguments for advanced usage.\nReturns:\n- result (array): The logarithm of the sum of the exponentials of the inputs."
  },
  "numpy.logaddexp2": {
    "new_func": "binary_exponential_sum_logarithm",
    "description": "Evaluates the logarithm in base-2 of the sum of two numbers where the inputs are given as logarithms in base-2. This method is particularly useful in scenarios where probabilities are too small and represented in the log2 domain for numerical stability.\nParameters:\n- x1, x2 (array_like): Arrays containing base-2 logarithms of the input values.\n- out (array, optional): An alternative output object to store the computed values.\n- where (array_like, optional): A boolean array that specifies where the operation should be performed.\n- **kwargs: Additional keyword arguments for advanced usage.\nReturns:\n- result (array): The base-2 logarithm of the sum of 2 raised to the power of the input values."
  },
  "numpy.logical_and": {
    "new_func": "elementwise_conjunction",
    "description": "Performs a conjunctive operation on corresponding elements of two input arrays. The result is an array with elements that are the logical intersection of the corresponding elements in the input arrays. The output shape is determined by broadcasting the input shapes if necessary.\nParameters:\n- input1, input2 (array_like): Arrays to perform the conjunction on.\n- out (array, optional): Alternate output array in which to place the result. It must have a shape that can accommodate the broadcasted inputs.\n- where (array_like, optional): A conditional array that determines where the operation is applied; if False at a certain index, the output at that index is left unchanged.\nReturns:\n- result (array): An array of booleans representing the conjunctive result."
  },
  "numpy.logical_not": {
    "new_func": "elementwise_negation",
    "description": "Applies a negation to each element of the input array, inverting their truth values. The resulting array has the same shape as the input.\nParameters:\n- input (array_like): The input array to apply negation.\n- out (array, optional): Alternate output array in which to place the result. It must have a shape that can accommodate the input.\n- where (array_like, optional): A conditional array that determines where the operation is applied; if False at a certain index, the output at that index is left unchanged.\nReturns:\n- result (array or bool): An array of booleans that are the inverse of the input array's truth values, or a single boolean if the input is a scalar."
  },
  "numpy.logical_or": {
    "new_func": "elementwise_disjunction",
    "description": "Performs a disjunctive operation on corresponding elements of two input arrays. The resulting array consists of elements that are the logical union of the corresponding elements in the input arrays. The output shape is established by broadcasting the input shapes if necessary.\nParameters:\n- input1, input2 (array_like): Arrays on which to perform the disjunction.\n- out (array, optional): An alternative array to store the result. It must have a shape that the inputs broadcast to.\n- where (array_like, optional): A conditional array that specifies which elements to operate on; if False at any index, the output at that index remains as is.\nReturns:\n- result (array): An array of booleans representing the disjunctive outcome."
  },
  "numpy.logical_xor": {
    "new_func": "elementwise_exclusive_disjunction",
    "description": "Applies an exclusive disjunctive operation to corresponding elements of two input arrays. The result is an array with elements that represent the exclusive union of the input elements\u2014true where only one is true and false where both are either true or false. The resulting shape conforms to the broadcasted input shapes.\nParameters:\n- input1, input2 (array_like): Input arrays to apply the exclusive disjunction.\n- out (array, optional): An alternative array to store the result. The shape must be suitable for the broadcasted inputs.\n- where (array_like, optional): A conditional array that specifies which elements to act upon; elements where condition is False will keep their original value in the output.\nReturns:\n- result (array or bool): An array of booleans showing the exclusive disjunctive result, or a single boolean if both inputs are scalars."
  },
  "numpy.logspace": {
    "new_func": "exponential_range",
    "description": "Generates an array of numbers that are evenly distributed on an exponential scale between two boundary values. The distribution begins at the first boundary value raised to the power of the base and ends with the second boundary value raised to the power of the base, inclusive if specified.\nParameters:\n- start (array_like): The exponent for the starting value.\n- stop (array_like): The exponent for the ending value.\n- num (int, optional): The count of samples to generate. Defaults to 50.\n- endpoint (bool, optional): If true, includes the stop value in the range. Default is true.\n- base (array_like, optional): The exponential base for the scale. Defaults to 10.\n- dtype (dtype): The desired data-type for the array. If not specified, the type is inferred from the other input values.\n- axis (int, optional): The axis in the result array along which the samples are stored. Default is 0.\nReturns:\n- samples (array): Samples that are uniformly distributed on a logarithmic scale."
  },
  "numpy.matrix": {
    "new_func": "two_dimensional_array_constructor",
    "description": "Constructs a two-dimensional array-like structure from a provided dataset or data string. This structure is designed to retain its bidimensional shape across operations, with specific operators for multiplicative actions and exponentiation. It is noted that usage of this constructor is discouraged in favor of generic arrays, and may be deprecated in the future. Parameters: - data (array_like or string): Input data to construct the array, with strings indicating rows and columns separated by semicolons and spaces or commas, respectively. - dtype (data-type): Desired data type for the elements within the array. - copy (bool): Indicates whether to create a copy of the input data or to construct a view. Returns: A new array-like structure with the specified properties."
  },
  "numpy.matmul": {
    "new_func": "array_product",
    "description": "Calculates the product of two arrays as if they are matrices. The function forbids scalar multiplication and employs broadcasting rules for arrays of more than two dimensions. Parameters: - x1, x2 (array_like): Input arrays for the operation. Scalars are not permitted. - out (array, optional): A location where the result is stored. If provided, it must have a compatible shape. If omitted, a new array is allocated. Returns: The result of the array product as an array. The result is scalar only when both input vectors are 1-dimensional. Raises a ValueError if input dimensions are misaligned or if a scalar is provided."
  },
  "numpy.mask_indices": {
    "new_func": "masked_entry_indices",
    "description": "Obtains indices for accessing square arrays of a given size using a specified mask function. The function generates a boolean array marking the presence or absence of elements according to the mask. Parameters: - n (int): Size of the arrays for which indices are generated. - mask_func (callable): A function that, when called with an array of shape (n, n) and an optional offset, returns a boolean array. - k (scalar): An optional offset for the mask function. Returns: A tuple of arrays containing indices where the mask function returns True for an array of ones with shape (n, n)."
  },
  "numpy.matrix_transpose": {
    "new_func": "bidimensional_flip",
    "description": "Performs transposition on a matrix or a stack of matrices, reversing the order of the two innermost dimensions. Parameters: - x (array_like): An input array with dimensions (..., M, N), where MxN matrices are to be transposed. Returns: An array with the matrices transposed, having dimensions (..., N, M)."
  },
  "numpy.median": {
    "new_func": "central_tendency_measure",
    "description": "Determines the middle value of an array when its elements are sorted. If the array is even-numbered, it returns the average of the two central values. Parameters: - a (array_like): Array or object convertible to an array. - axis (int, sequence of int, None, optional): Axis along which to compute the median. If None, the median is computed along a flattened version of the array. - out (array, optional): An alternative array to store the result. - overwrite_input (bool, optional): If True, allows using the input array's memory for calculations, altering its contents. - keepdims (bool, optional): If True, the reduced axes are retained with size one for broadcasting. Returns: An array with the median values. If the input contains smaller types than float64, the output type is float64; otherwise, it matches the input type."
  },
  "numpy.max": {
    "new_func": "peak_value",
    "description": "Identify the highest value within an array or along a specified axis. Parameters: - array_data: array_like, Data to be evaluated. - axis: None, int, or tuple of ints, optional, Determines the dimension(s) for operation. Default evaluates the entire array. - result_array: array, optional, An array to store the output. Must match the expected output shape. - retain_dimensions: bool, optional, If set, the reduced dimensions are kept with a size of one for broadcasting. - initial_value: scalar, optional, Minimum possible value to start the comparison. Useful for empty slices. - conditional_elements: array_like of bool, optional, Specifies elements to be considered for the operation. Returns: - peak: array or scalar, The highest value found. Scalar if no axis is specified, otherwise an array with reduced dimensions."
  },
  "numpy.mean": {
    "new_func": "average_value",
    "description": "Calculate the arithmetic average across the specified axis. Parameters: - array_data: array_like, Collection of numbers to compute the average. If not an array, a conversion attempt is made. - axis: None, int, or tuple of ints, optional, The dimension(s) along which to compute the average. Defaults to the entire array. - dtype: data-type, optional, The data type used for computation. Defaults to float64 for integer inputs, or the same as input array for floating-point inputs. - result_array: array, optional, An alternate array to place the result. Must match the expected output shape if provided. - retain_dimensions: bool, optional, If set, keeps reduced dimensions with size one for correct broadcasting. - conditional_elements: array_like of bool, optional, Specifies the elements to include in the average. Returns: - avg: array, The computed average, with the same data type as specified by dtype parameter. If result_array is None, a new array is created for the output."
  },
  "numpy.maximum": {
    "new_func": "elemental_peak",
    "description": "Perform element-wise comparison of two arrays and return a new array with the element-wise highest values. If either element being compared is a NaN, the NaN is returned, favoring the first array in case of two NaNs. Parameters: - input1, input2: array_like, Input arrays to compare. Must be broadcastable to a common shape. - result_array: array, optional, Array to store the result. Must be of broadcast shape if provided. - condition: array_like, optional, Specifies where to apply the operation. If False at a location, the result_array retains its original value there. - kwargs: additional arguments like casting, order, dtype, and subok, that control the behavior of the operation. Returns: - comparison_result: array or scalar, The element-wise highest values. Scalar if both inputs are scalars."
  },
  "numpy.may_share_memory": {
    "new_func": "potential_overlap_check",
    "description": "Assess if two arrays could potentially share memory. A True result does not guarantee shared elements but indicates the possibility. The function primarily checks the memory bounds. Parameters: - array1, array2: array, Input arrays to check for potential overlap. - max_effort: int, optional, Level of effort to determine overlap; higher values perform a thorough check. Defaults to a basic bounds check. Returns: - possibility: bool, Indicates whether there's a chance the arrays share memory."
  },
  "numpy.meshgrid": {
    "new_func": "coordinate_matrix",
    "description": "Generate coordinate matrices from one-dimensional coordinate vectors, suitable for vectorized evaluations over a grid. Parameters: - vectors: array_like, One-dimensional arrays representing grid coordinates. - indexing_scheme: {'xy', 'ij'}, optional, Determines output indexing ('xy' for Cartesian or 'ij' for matrix indexing). - sparse_output: bool, optional, If True, reduces dimensions of output arrays for efficient broadcasting. - copy_arrays: bool, optional, If False, returns views to original arrays to save memory. Returns: - grid_matrices: tuple of arrays, Arrays representing grid coordinates, with shapes corresponding to the input vectors and the specified indexing scheme."
  },
  "numpy.memmap": {
    "new_func": "binary_file_array_map",
    "description": "Map an array to a binary file on disk, allowing for large data manipulation without loading the entire file into memory. This is particularly useful for working with segments of extensive datasets. Parameters: - filename (str, file-like object, or pathlib.Path): Path to the file used as the data buffer. - dtype (data-type, optional): Data-type to interpret the file contents. Defaults to uint8. - mode (str, optional): Mode in which to open the file. Options include 'r' (read-only), 'r+' (read-write), 'w+' (write, possibly overwriting), and 'c' (copy-on-write). - offset (int, optional): Byte offset in the file where array data starts. - shape (int or sequence of ints, optional): Shape of the resulting array. If not provided, a 1-D array is assumed. - order (str, optional): Memory layout of the array, either 'C' (row-major) or 'F' (column-major). Returns: A memory-mapped array object that behaves like an array but stores its contents in a binary file on disk."
  },
  "numpy.mgrid": {
    "new_func": "dense_coordinate_matrix_generator",
    "description": "Generate dense multi-dimensional coordinate matrices for vectorized evaluations of multivariate grids. Parameters: None explicitly, but indexing the instance with slices and complex-step lengths determines the range and density of the mesh. Returns: A stacked set of arrays representing the grid coordinates, with each array having the same dimensionality."
  },
  "numpy.min": {
    "new_func": "array_floor",
    "description": "Determine the smallest value in an array or along a specified axis. Parameters: - a (array_like): Input data. - axis (None, int, or tuple of ints, optional): Axis to perform the operation on. Default is None for flattened input. - out (array, optional): Alternative output array to store the result. - keepdims (bool, optional): Whether to retain reduced axes with length one. - initial (scalar, optional): Initial value to start comparison with. - where (array_like of bool, optional): Condition to choose elements for comparison. Returns: The smallest values in the array: a scalar if 'axis' is None, otherwise an array with dimensions reduced according to 'axis'."
  },
  "numpy.minimum": {
    "new_func": "elementary_floor",
    "description": "Compute the element-wise smallest value between two arrays. Parameters: - x1, x2 (array_like): Input arrays for comparison. - out (array, optional): Array to store the results. - where (array_like, optional): Condition under which the operation is performed. Returns: An array with the element-wise minimum values, which is scalar if both inputs are scalars."
  },
  "numpy.min_scalar_type": {
    "new_func": "minimal_fitting_dtype",
    "description": "Identify the smallest data type capable of holding a given scalar value without demoting its type. For an array input, the data type of the array is returned unchanged. Parameters: - a (scalar or array_like): Value or array to find the minimal data type for. Returns: The smallest data type that can contain the value 'a' without type demotion."
  },
  "numpy.mintypecode": {
    "new_func": "smallest_type_selector",
    "description": "Determines the smallest data type character from a list or array that can handle the data, choosing from a specified set of type characters. The function selects from the set based on the ability to safely cast all types provided to the smallest size data type. Parameters: - typechars (list of str or array_like): List of data type strings or an array from which to derive the character representation of the data type. - typeset (str or list of str, optional): A set of characters to choose the return character from, with a default set. - default (str, optional): The default character returned if no match is found in the typeset. Returns: - typechar (str): The character denoting the identified minimum-size data type."
  },
  "numpy.moveaxis": {
    "new_func": "axis_relocator",
    "description": "Repositions specified axes of an array to new indices, while keeping the remaining axes in their original sequence. Parameters: - array (array): The array to modify. - source (int or sequence of int): The original positions of the axes to be moved. - destination (int or sequence of int): The new positions for the original axes. Returns: - result (array): A modified view of the input array with the specified axes moved to their new positions."
  },
  "numpy.mod": {
    "new_func": "elementwise_remainder",
    "description": "Calculates the element-wise division remainder of two input arrays. The result has the same sign as the divisor and is equivalent to the remainder when the dividend is divided by the divisor using floor division. Parameters: - dividend (array_like): The numerator array. - divisor (array_like): The denominator array. Returns: - remainder (array): The element-wise remainder resulting from the division."
  },
  "numpy.modf": {
    "new_func": "fraction_integral_part",
    "description": "Decomposes each element in the input array into its fractional and whole number components. Both parts take the sign of the input number. Parameters: - input_array (array_like): The array to be decomposed. Returns: - fractional_part (array): The fractional component of the input array. - integral_part (array): The integral component of the input array."
  },
  "numpy.multiply": {
    "new_func": "elementwise_product",
    "description": "Computes the product of two arrays on an element-by-element basis. If the shapes of the arrays are not identical, broadcasting rules apply to achieve a common shape. Parameters: - factor1, factor2 (array_like): The arrays to be multiplied together. Returns: - product (array): An array containing the products of the elements from the input arrays."
  },
  "numpy.nanargmin": {
    "new_func": "ignore_nan_minimum_index",
    "description": "Identify the location of the smallest value, disregarding any 'Not a Number' (NaN) entries. In scenarios where a segment only has NaNs or infinities, a ValueError is raised. Parameters: - data (array_like): The input sequence. - axis (int, optional): Dimension along which to find the index. Default is to use the entire array. - result (array, optional): An existing array to store the result. Must have the correct shape and data type. - keep_dims (bool, optional): Maintain reduced dimensions as size one, enabling correct broadcasting. Returns: - indices (array): Array of indices indicating the location of the minimum value, ignoring NaNs."
  },
  "numpy.nanargmax": {
    "new_func": "ignore_nan_maximum_index",
    "description": "Determine the position of the largest value while ignoring 'Not a Number' (NaN) elements. Throws a ValueError if a segment contains only NaNs or negative infinities. Parameters: - data (array_like): The input array to process. - axis (int, optional): Dimension to perform the operation along. Default is to consider the array as a whole. - result (array, optional): Array to store the output if provided. Must match the intended shape and data type. - keep_dims (bool, optional): If set, retains reduced dimensions with size one, ensuring proper broadcasting. Returns: - indices (array): Array with indices of the maximum values, NaNs omitted."
  },
  "numpy.nancumprod": {
    "new_func": "ignore_nan_cumulative_product",
    "description": "Compute the cumulative product of elements across a given dimension, treating NaNs as one. The cumulative product remains unchanged upon encountering NaNs, and initial NaNs are substituted with ones. If a segment is entirely NaNs or empty, ones are returned. Parameters: - data (array_like): Input sequence. - axis (int, optional): Dimension for the cumulative operation. By default, the input is flattened. - data_type (dtype, optional): Data type for the returned array and the accumulator that multiplies the elements. - output (array, optional): Alternate array to hold the result. Must have an equivalent shape and buffer length as the expected output. Returns: - cumprod_result (array): The cumulative product array, with the same shape as the input data, unless specified otherwise in the output."
  },
  "numpy.nan_to_num": {
    "new_func": "replace_special_values",
    "description": "Substitute NaNs with zero or a specified value, and infinities with large finite numbers or user-specified values. For inexact types, NaNs get replaced by zero or the nan keyword value, and infinities are substituted with the largest representable finite floating-point values or the user-defined posinf and neginf values. This is applied separately to the real and imaginary parts of complex types. For non-inexact types, no substitutions occur. Parameters: - input_data (scalar or array_like): Input data to process. - make_copy (bool, optional): Whether to create a copy of the input data or replace values in place. - nan_value (int, float, optional): Value to use for replacing NaNs. - positive_inf (int, float, optional): Value to replace positive infinity. - negative_inf (int, float, optional): Value to replace negative infinity. Returns: - output_data (array): Processed data with non-finite values replaced; may be the input array itself if make_copy is False."
  },
  "numpy.nancumsum": {
    "new_func": "ignore_nan_cumulative_sum",
    "description": "Calculate the cumulative sum of array elements along a specified dimension, considering NaNs as zero. The cumulative sum is unaffected by NaNs, and leading NaNs are replaced by zeros. Slices entirely consisting of NaNs or being empty yield zeros. Parameters: - data (array_like): Input array to process. - axis (int, optional): Dimension along which the cumulative sum is computed. Defaults to the entire array if not specified. - data_type (dtype, optional): Data type for the return array and the accumulator for the sum. - output (array, optional): Alternate array to store the result, required to have the same shape and buffer length as the expected output. Returns: - cumsum_result (array): Array containing the cumulative sum, with an identical size to the input and the same shape if an axis is specified or if the array is one-dimensional."
  },
  "numpy.nanmax": {
    "new_func": "peak_ignore_null",
    "description": "Find the greatest element within a collection, disregarding any undefined numerical values. When a segment of the collection contains only undefined numerical values, a warning is issued and such segment yields an undefined numerical value. Parameters: - collection (array_like): The collection of numbers to evaluate. - axis (optional): The dimension(s) along which to evaluate. Default is the entire collection. - destination (array, optional): An alternative array to store the result. - persist_dims (bool, optional): If True, reduced dimensions are retained with size one. - starting_point (scalar, optional): Initial value to be used for empty slices. - include_elements (array_like of bool, optional): Specifies which elements to consider. Returns: - peak (array): An array with the greatest elements, with the same shape as the input collection minus the specified axis."
  },
  "numpy.nanmean": {
    "new_func": "average_ignore_null",
    "description": "Determine the arithmetic average across a specific dimension, excluding undefined numerical values. The average calculation is over the entire collection by default, or along a given dimension. For integer collections, a floating-point mean is calculated. If the collection only contains undefined numerical values, the result is undefined and a warning is raised. Parameters: - collection (array_like): The collection of numbers to evaluate. - axis (optional): The dimension(s) along which to determine the mean. - data_type (data-type, optional): Desired data type for the mean. - destination (array, optional): An alternative array to store the result. - persist_dims (bool, optional): If True, reduced dimensions are retained with size one. - include_elements (array_like of bool, optional): Specifies which elements to include. Returns: - average (array): The result of the average computation, either as a new array or in the provided destination."
  },
  "numpy.nanmedian": {
    "new_func": "middle_value_ignore_null",
    "description": "Calculate the median of the provided collection along a specified dimension, while overlooking any undefined numerical values. The median returns the middle element of the array after sorting. Parameters: - collection (array_like): Input data to process. - axis (optional): Dimension(s) along which to compute the median. - destination (array, optional): Alternative output array for the result. - use_input_memory (bool, optional): If True, computation may modify the input data. - persist_dims (bool, optional): If True, reduced dimensions remain in the result with size one. Returns: - median (array): A new array containing the median values, or a reference to the provided destination array."
  },
  "numpy.nanmin": {
    "new_func": "trough_ignore_null",
    "description": "Identify the smallest element within a set while excluding undefined numerical values. If a segment only includes undefined values, a warning is conveyed and the result for that segment is undefined. Parameters: - set (array_like): The set of numbers to assess. - axis (optional): The dimension(s) along which to find the smallest value. - destination (array, optional): An alternate array to store the result. - persist_dims (bool, optional): If True, keeps reduced dimensions with size one. - starting_point (scalar, optional): The starting value for the reduction on empty slices. - include_elements (array_like of bool, optional): Indicates which elements to include for evaluation. Returns: - trough (array): An array with the smallest elements, preserving the original set's shape minus the specified axis."
  },
  "numpy.nanprod": {
    "new_func": "aggregate_ignore_null",
    "description": "Compute the product of elements across a given dimension, treating undefined numerical values as unity. A result of one is given for segments that are all-undefined or empty. Parameters: - sequence (array_like): The sequence of numbers for the product computation. - axis (optional): The dimension(s) along which to calculate the product. - data_type (data-type, optional): The desired data type for the product calculation. - destination (array, optional): An alternative array to hold the result. - persist_dims (bool, optional): If True, retains reduced dimensions with size one. - starting_value (scalar, optional): The initial value for the product calculation on empty segments. - include_elements (array_like of bool, optional): Specifies which elements to factor into the product. Returns: - aggregate (array): A new array containing the product, or a reference to the provided destination."
  },
  "numpy.nanpercentile": {
    "new_func": "ignore_nan_rank",
    "description": "Calculates the specific point below which a given percentage of observations in a dataset falls, disregarding any non-number elements. Parameters: - a (array_like): Input array with possibly non-number elements to ignore. - q (array_like of float): Value or sequence of values between 0 and 100 indicating the percentile rank(s) to calculate. - axis (optional): Axis or axes along which to compute the rank(s). Default is a flattened array. - out (optional): Alternative array to store the result. - overwrite_input (optional): If True, allows modification of the input array to save memory. - method (optional): Technique for estimating the rank. Various methods offered, default is 'linear'. - keepdims (optional): If True, reduced axes are preserved as dimensions with size one. - weights (optional): Weights for the values in the input array. Returns: - percentile (scalar or array): The calculated percentile rank(s) for the input array. If q is a single percentile and axis is None, a scalar is returned. If multiple percentiles are used, the first axis of the result corresponds to the percentiles."
  },
  "numpy.nanquantile": {
    "new_func": "ignore_nan_fraction",
    "description": "Computes the specific point in the dataset at which a given fraction of the data lies below it, ignoring non-number elements. Parameters: - a (array_like): Input array with non-number elements to be ignored. - q (array_like of float): Fraction or sequence of fractions for the quantile(s) to compute, between 0 and 1. - axis (optional): Axis or axes along which the quantiles are computed. - out (optional): Alternative array for output. - overwrite_input (optional): Allows input array modification to save memory. - method (optional): Technique to estimate the quantile. - keepdims (optional): Preserves reduced axes with size one for broadcasting. - weights (optional): Weights associated with values in the input array. Returns: - quantile (scalar or array): The computed quantile(s) for the input array. Returns a scalar if a single quantile is computed with no axis specified, or an array for multiple quantiles."
  },
  "numpy.nanstd": {
    "new_func": "omit_nan_deviation",
    "description": "Determines the dispersion metric of a dataset, which is a quantification of the amount of variation or dispersion, excluding non-number elements. Parameters: - a (array_like): Input array with non-number values. - axis (optional): Axis over which to calculate the metric. - dtype (optional): Data type for computation. - out (optional): Alternative array for result. - ddof (optional): 'Delta Degrees of Freedom' for the divisor in the calculation. - keepdims (optional): Retains reduced dimensions with unit length. - where (optional): Condition for including elements in the computation. - mean (optional): Precomputed mean for efficiency. Returns: - standard_deviation (array): The calculated dispersion metric of the non-NaN elements. If ddof is greater than the number of non-NaN elements or if all elements are NaN, the result is NaN."
  },
  "numpy.nansum": {
    "new_func": "exclude_nan_total",
    "description": "Accumulates the elements of the array, treating non-numbers as zero, along a given axis or axes. Parameters: - a (array_like): Input data with non-number elements considered as zero. - axis (optional): Axis for summation. - dtype (optional): Data type for the returned array and accumulator. - out (optional): Alternative output array. - keepdims (optional): Maintains reduced dimensions. - initial (optional): Starting value for sum. - where (optional): Condition to decide which elements to include. Returns: - nansum (array): The sum of the array elements, excluding any non-number values."
  },
  "numpy.nanvar": {
    "new_func": "neglect_nan_dispersion",
    "description": "Calculates the squared deviation of the dataset's mean, excluding non-number elements, which is an indication of the dataset's variability. Parameters: - a (array_like): Input array to compute variability from. - axis (optional): Axis or axes along which to compute the measure. - dtype (optional): Data type for the computation. - out (optional): Alternative output array. - ddof (optional): Represents 'Delta Degrees of Freedom' in the calculation. - keepdims (optional): Keeps the reduced axis as dimension with size one. - where (optional): Specifies elements to include in the calculation. - mean (optional): Precomputed mean value for the input array. Returns: - variance (array): The calculated squared deviation from the mean, excluding NaN elements. In cases where ddof is equal to or larger than the number of non-NaN elements, or where the slice only contains NaNs, the result is NaN."
  },
  "numpy.ndim": {
    "new_func": "array_dimensionality",
    "description": "Determine how many axes an array-like structure has. Parameters: - input: array_like, a variable to inspect for axes count. Returns: - axes_count: int, The total count of axes in the provided variable. Scalar values will return zero."
  },
  "numpy.ndenumerate": {
    "new_func": "multi_axis_iterator",
    "description": "Yields coordinate-indexed elements across all dimensions of an input array. Parameters: - input_array: array, Array to iterate over. Returns: An iterator which provides a tuple containing the multi-dimensional index and its corresponding value."
  },
  "numpy.ndindex": {
    "new_func": "multi_dimensional_indices",
    "description": "Provides an iterator to traverse over index-tuples that map out the shape of an array with given dimensions. Parameters: - dims: ints or a single tuple of ints, The size of each axis of the hypothetical array. Returns: An iterator that yields tuples representing the indices of an N-dimensional grid."
  },
  "numpy.nonzero": {
    "new_func": "elemental_indices",
    "description": "Identify the indices where elements of the input are non-trivial (not equal to zero). Parameters: - input_array: array_like, Array to be analyzed. Returns: - index_tuples: tuple of arrays, Each array corresponds to a dimension of the input, containing the indices of elements with non-trivial values."
  },
  "numpy.nested_iters": {
    "new_func": "multi_axis_iterators",
    "description": "Generate a sequence of iterator objects for iterating over multiple axes in a nested loop fashion. Each iterator corresponds to a specific axis, with the first iterator corresponding to the outermost loop and the last to the innermost loop. Moving one iterator forward affects the position of subsequent iterators accordingly. Parameters: - op (array or sequence of array_like): The array(s) to be iterated over. - axes (list of list of int): Specifies the axes for each iterator. - flags, op_flags, op_dtypes, order, casting, buffersize: Various optional parameters to configure the iterators. Returns: - iters (tuple of nditer): A tuple containing an iterator for each axis list, starting with the outermost axis."
  },
  "numpy.not_equal": {
    "new_func": "elementwise_inequality",
    "description": "Compares two arrays element-wise and returns a boolean array indicating where the corresponding elements differ. Parameters: - x1, x2 (array_like): Input arrays to be compared. The shapes must be compatible for broadcasting. - out (array, None, or tuple of array and None, optional): A location to store the result. If not provided, a new array is allocated. - where (array_like, optional): A condition to apply over the inputs. Only positions where this condition is true will be evaluated. Returns: - out (array or scalar): A boolean array with the result of element-wise inequality, or a scalar if both inputs are scalars."
  },
  "numpy.ogrid": {
    "new_func": "open_mesh_creator",
    "description": "Provides a multi-dimensional object that generates an open mesh-grid when indexed, creating arrays with only one dimension larger than one. The output dimensionality matches the indexing dimensions. If the indexing step is a complex number, the magnitude's integer part specifies the number of points between start and stop, inclusive of the endpoint. Returns: - mesh-grid (array or tuple of arrays): If a single slice is input, an array is returned; for multiple slices, a tuple of arrays is returned, with each array having a single dimension larger than one."
  },
  "numpy.ones": {
    "new_func": "unity_fill",
    "description": "Produces an array with the specified shape, filled entirely with the value one. Parameters: - shape (int or sequence of ints): The dimensions of the resulting array. - dtype (data-type, optional): The desired type for the elements of the array. Default is a floating-point type. - order ({'C', 'F'}, optional): Determines whether to store the array in row-major or column-major memory order. Returns: - out (array): An array of the specified shape and data type, filled with ones."
  },
  "numpy.ones_like": {
    "new_func": "unity_mirror",
    "description": "Creates a new array with the same shape and type as an existing one, with all elements set to one. Parameters: - a (array_like): The model array whose shape and data type determine those of the result. - dtype (data-type, optional): Specifies a different data type for the new array. - order ({'C', 'F', 'A', 'K'}, optional): Specifies the desired memory layout for the new array. - subok (bool, optional): If true, the result will be of the same subtype as the model array; otherwise, it will be a base-class array. - shape (int or sequence of ints, optional): If provided, overrides the shape of the new array. Returns: - out (array): An array with the same shape and type as the model array, filled with ones."
  },
  "numpy.outer": {
    "new_func": "vector_product_matrix",
    "description": "Calculate the matrix product of two 1-dimensional arrays to produce a 2D matrix with each element being the product of elements from the input arrays. Parameters: - first_vector (M,) array_like: The first input vector. Flattened if not 1-dimensional. - second_vector (N,) array_like: The second input vector. Flattened if not 1-dimensional. - destination (M, N) array, optional: A location to store the result. Returns: - product_matrix (M, N) array: The resulting matrix where product_matrix[i, j] = first_vector[i] * second_vector[j]."
  },
  "numpy.packbits": {
    "new_func": "binary_compression",
    "description": "Condense the elements of a binary-valued array into bits within a uint8 array, padding the result to complete bytes with zero bits if necessary. Parameters: - input_array: array_like, An array of integers or booleans to be packed into bits. - dimension: int, optional, The axis over which to perform the packing. Defaults to None, indicating a flattened array. - bit_order: {'big', 'little'}, optional, The bit order to use during packing. Defaults to 'big'. Returns: - compressed_array: array, An uint8 array with bits representing the logical value (0 or nonzero) of the input elements."
  },
  "numpy.pad": {
    "new_func": "extend_boundaries",
    "description": "Augment an array by adding specified widths of padding along each axis, using various filling strategies. Parameters: - input_array: array_like of rank N, The array to augment. - padding_width: {sequence, array_like, int}, Specifies the amount of padding added to each edge. - padding_mode: str or function, optional, Dictates the method of padding. Options include 'constant', 'edge', 'linear_ramp', etc. Additional keywords are available depending on padding_mode. Returns: - augmented_array: array, The augmented array with added padding."
  },
  "numpy.partition": {
    "new_func": "partial_sort_divider",
    "description": "Rearrange a copy of the array such that the element at the nth position is the one that would be in that position in a sorted array, with all elements smaller than that element before it and all larger elements behind it. The order of elements in the partitions is unspecified. Parameters: - source_array: array_like, Array to be partitioned. - nth_element: int or sequence of ints, Index of the element to partition by. - axis: int or None, optional, Axis to partition along. Default is -1 (last axis). - selection_algorithm: {'introselect'}, optional, Algorithm used for selection. Default is 'introselect'. - ordering: str or list of str, optional, Field(s) to compare for structured arrays. Returns: - partitioned_array: array, Array of the same type and shape as source_array, partitioned by nth_element."
  },
  "numpy.nditer": {
    "new_func": "multi_dimensional_traversal",
    "description": "Create an efficient iterator for traversing over arrays in multiple dimensions. Can be used to iterate in a chosen order, with options for read/write and buffering behavior. Parameters: - target_arrays: array or sequence of array_like, Arrays to iterate over. - iteration_flags: sequence of str, optional, Flags to control iterator behavior. - operand_flags: list of list of str, optional, Flags for each operand, such as 'readonly' or 'readwrite'. - operand_types: dtype or tuple of dtype(s), optional, Data types for the operands. - iteration_order: {'C', 'F', 'A', 'K'}, optional, Iteration order over the array. - type_casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional, Allowed data casting types. - operand_axes: list of list of ints, optional, Mapping from iterator dimensions to operand dimensions. - iterator_shape: tuple of ints, optional, The desired shape of the iterator. - buffer_size: int, optional, Size of temporary buffers for iteration. Returns: - iterator_object: nditer, An iterator object for traversing arrays."
  },
  "numpy.negative": {
    "new_func": "invert_signs",
    "description": "Calculate the additive inverse of each element in the input data, element-wise. Parameters: - x (array_like or scalar): The input values. - out (array, None, tuple): Optional output location for the result. Must have a compatible shape with the input. - where (array_like, optional): A boolean condition to specify where the inversion should be applied; the rest remains unchanged. - casting, order, dtype, subok: Advanced control of casting, memory order, and type. Returns: - y (array or scalar): The element-wise additive inverse of the input data."
  },
  "numpy.percentile": {
    "new_func": "quantile_calculation",
    "description": "Evaluate specific quantile levels within the data set. Parameters: - a (array_like of real numbers): Input data to evaluate. - q (array_like of float): Quantile or sequence of quantiles to compute, between 0 and 100. - axis (int, tuple of int, None, optional): Axis to compute quantiles along. Default is a flattened version of the array. - out (array, optional): Alternative output for the result. - overwrite_input (bool, optional): Allows modification of input array to save memory. - method (str, optional): Algorithm for estimating percentiles. - keepdims (bool, optional): Preserves reduced axes with size one. - weights (array_like, optional): Weights for weighted percentile calculation. Returns: - percentile (scalar or array): The computed percentile values. Scalar if a single percentile and axis=None."
  },
  "numpy.permute_dims": {
    "new_func": "axis_shuffle",
    "description": "Rearrange the dimensions of an array according to a specified scheme. Parameters: - a (array_like): Input array to transpose. - axes (tuple or list of ints, optional): Desired ordering of axes; defaults to reversing the order of the axes. Returns: - p (array): Array with its axes permuted. A view is returned whenever possible."
  },
  "numpy.piecewise": {
    "new_func": "conditional_evaluation",
    "description": "Perform function evaluation over specified segments of input data. Parameters: - x (array or scalar): The domain to evaluate. - condlist (list of bool arrays or bool scalars): Conditions defining the segments. - funclist (list of callables or scalars): Functions corresponding to each segment. - args, kw (optional): Additional arguments and keywords passed to functions. Returns: - out (array): The evaluated output with the same shape as input. Segments are filled based on their corresponding function."
  },
  "numpy.place": {
    "new_func": "conditional_insert",
    "description": "Modify an array in-place by inserting values according to a mask. Parameters: - arr (array): The array to modify. - mask (array_like): A boolean array of the same size as 'arr'. - vals (1-D sequence): Values to insert into 'arr'. The sequence is repeated if necessary and should be non-empty if elements are masked. Returns: None, but 'arr' is modified with the values from 'vals' where 'mask' is True."
  },
  "numpy.nextafter": {
    "new_func": "adjacent_float",
    "description": "Returns the adjacent floating-point value towards the second argument from the first argument, evaluated element by element. Parameters: - x1 (array_like): Values to find the next representable number. - x2 (array_like): The direction in which the next representable number is sought. Must be broadcastable to a common shape with x1. - out (array, optional): A location to store the result. Must be broadcastable to the inputs' shape. Default is a new array. - where (array_like, optional): A boolean array that specifies where to apply the operation. - **kwargs: Additional arguments specifying casting rules and more. Returns: - out (array or scalar): The next representable numbers of x1 towards x2. Scalar if both inputs are scalars."
  },
  "numpy.poly1d": {
    "new_func": "polynomial_encapsulator",
    "description": "Encapsulates operations on single-variable polynomials allowing for natural algebraic operations within code. Parameters: - c_or_r (array_like): Coefficients of the polynomial in decreasing power, or the roots if the second parameter is True. - r (bool, optional): If True, the first argument is treated as roots. Default is False. - variable (str, optional): The variable name to use when representing the polynomial as a string. Returns: An object representing the polynomial, which allows for arithmetic operations, evaluation, differentiation, and integration."
  },
  "numpy.poly": {
    "new_func": "root_coefficients",
    "description": "Determines the coefficients of a monic polynomial given a sequence of its zeros. Parameters: - seq_of_zeros (array_like): A sequence of zeros or a square matrix whose characteristic polynomial is to be found. Returns: - c (array): A 1D array of polynomial coefficients in descending powers, where the leading coefficient is guaranteed to be one."
  },
  "numpy.polyder": {
    "new_func": "polynomial_differentiator",
    "description": "Computes the derivative of the specified order for a given polynomial. Parameters: - p (poly1d or sequence): Coefficients of the polynomial or a poly1d object. - m (int, optional): The order of differentiation. Default is 1. Returns: - der (poly1d): The derivative of the polynomial as a new poly1d object."
  },
  "numpy.polydiv": {
    "new_func": "polynomial_divider",
    "description": "Performs division of two polynomials, returning the quotient and remainder. Parameters: - u (array_like or poly1d): Coefficients of the dividend polynomial. - v (array_like or poly1d): Coefficients of the divisor polynomial. Returns: - q (array): Coefficients of the quotient polynomial. - r (array): Coefficients of the remainder polynomial."
  },
  "numpy.prod": {
    "new_func": "aggregate_multiplication",
    "description": "Calculates the cumulative multiplication of elements along a specified dimension or across the entire array if no dimension is specified. Parameters: - input_data (array_like): The array whose elements are to be multiplied. - dimension (None, int, or tuple of ints, optional): The dimension along which multiplication is performed. Defaults to None, resulting in multiplication over all elements. - accumulator_dtype (dtype, optional): The desired data type for the result and the accumulator. Defaults to the input array's dtype for integer types with less precision than the default platform integer. - target (array, optional): An alternate array where the result is placed. Must have the same shape as the expected output. - dimension_preservation (bool, optional): If True, reduced dimensions are retained with size one, enabling proper broadcasting. - start_value (scalar, optional): The initial value for the multiplication. - condition (array_like of bool, optional): Conditions that determine which elements are included in the multiplication. Returns: - result (array): An array with the same shape as the input, sans the specified dimension, containing the products."
  },
  "numpy.promote_types": {
    "new_func": "minimal_castable_dtype",
    "description": "Determines the smallest size and least precise data type to which two different data types can both be safely cast, ensuring the result is always in native byte order. This operation is symmetric and typically used to find a common data type for combined operations on arrays. Parameters: - first_dtype (dtype or dtype specifier): The first data type to consider. - second_dtype (dtype or dtype specifier): The second data type to consider. Returns: - canonical_dtype (dtype): A data type to which both input types can be safely cast, with the smallest size and least precision."
  },
  "numpy.put": {
    "new_func": "assign_values",
    "description": "Places specified values into an array at targeted flat indices. If the provided values are fewer than the indices, repetition of values occurs. Parameters: - target_array (array): The array to modify. - target_indices (array_like): Flat indices where values are to be placed. - new_values (array_like): Values to insert at the specified indices. - out_of_bounds_behavior ({'raise', 'wrap', 'clip'}, optional): Determines how to handle indices that are out of bounds. Defaults to 'raise', which triggers an error. Returns: None; modifies the target_array in-place."
  },
  "numpy.ptp": {
    "new_func": "span_amplitude",
    "description": "Computes the span, or the difference between the maximum and the minimum of an array along a specified axis. This operation is also known as the 'peak to peak' measurement. Caution should be exercised with signed integer data types, as the result may appear negative due to modular arithmetic. Parameters: - input_array (array_like): The input values for which the range is computed. - dimension (None, int, or tuple of ints, optional): The axis or axes along which to calculate the range. Defaults to None, which flattens the array. - alternative_output (array_like, optional): An alternate array to store the result. Must have the same shape and buffer length as the expected output. - keep_dimensionality (bool, optional): If True, retains reduced dimensions as singleton dimensions, allowing for correct broadcasting. Returns: - range (array or scalar): The computed range of values for each 1-D slice along the specified axis, or the overall range if the axis is None."
  },
  "numpy.put_along_axis": {
    "new_func": "index_matched_assignment",
    "description": "Inserts values into an array based on matching 1D index and data slices along a specified axis. This function iterates over 1D slices and assigns values from the data array to the destination array using the corresponding index array. Parameters: - dest_array (array): The array where values are to be inserted. - index_slices (array): 1D index slices matching data slices for insertion. Must be broadcastable to fit the destination array. - insert_values (array_like): Values to be inserted according to index slices. Dimensions must be compatible for broadcasting with index_slices. - selected_axis (int): Axis along which to perform the operation. If None, the dest_array is treated as if it were flattened. Returns: None; modifies the dest_array in-place."
  },
  "numpy.putmask": {
    "new_func": "assign_conditionally",
    "description": "Alters elements of an array according to a boolean mask and a set of replacement values. Elements in the target array are replaced with the corresponding element from the values array wherever the mask is True. If the values array is shorter than the target, its entries are cycled. This differs from direct indexing replacement, as it modifies the array in-place and can handle broadcasting of the replacement values. Parameters: - target_array (array): The array to modify. - condition_mask (array_like): A boolean array with the same shape as the target array. - replacement_values (array_like): The values to insert where the condition mask is True. If smaller than the target array, it will be repeated. Returns: - None: The target array is modified in-place."
  },
  "numpy.quantile": {
    "new_func": "fractional_rank",
    "description": "Calculates the specified percentiles of an array along a given axis, based on sorted data. It can compute multiple percentiles at once and uses various methods to interpolate between data points if the percentile does not correspond to an exact position in the input. Parameters: - data (array_like): Input data to compute the percentiles from. - probabilities (array_like): Percentile or sequence of percentiles to compute, must be between 0 and 1. - axis (int, tuple of int, None, optional): Axis along which to compute the percentiles. Defaults to a flattened version of the array. - output_array (array, optional): An alternative output array to place the result. It must be of the appropriate shape. - in_place (bool, optional): Allows modification of the input data to save memory. - estimation_method (str, optional): Method for percentile estimation. - keep_dimensions (bool, optional): If True, reduced axes are left in the result as dimensions with size one. - weights (array_like, optional): Weights associated with the values in the input data. - interpolation (str, optional): Deprecated alias for estimation_method. Returns: - result (scalar or array): The computed percentiles. If only one percentile is computed and axis is None, the result is a scalar. Otherwise, it is an array."
  },
  "numpy.r_": {
    "new_func": "axis_concatenator",
    "description": "Facilitates the joining of array sequences along the first dimension using a special syntax in the form of an index expression. It can handle the stacking of arrays separated by commas or the creation of arrays with ranges specified by slice notation. This construct allows for an intuitive way of building up arrays quickly. Parameters: - This is not a traditional function and does not take parameters in the conventional sense. Returns: - concatenated_array (array): The result of the concatenation along the specified axis or axes."
  },
  "numpy.rad2deg": {
    "new_func": "radian_to_degree",
    "description": "Transforms angle values from radians to degrees. Parameters: - angle_rad (array_like): Input angle(s) in radians. - output_array (array, optional): Alternative array to store the result. Must be broadcast-compatible with the expected output. - condition (array_like, optional): Condition array for selective transformation. - casting, order, dtype, subok (optional): Control the behavior of casting and memory ordering. Returns: - angle_deg (array): Angle(s) converted to degrees."
  },
  "numpy.radians": {
    "new_func": "degree_to_radian",
    "description": "Transforms angle values from degrees to radians. Parameters: - angle_deg (array_like): Input angle(s) in degrees. - output_array (array, optional): Alternative array to store the result. Must be broadcast-compatible with the expected output. - condition (array_like, optional): Condition array for selective transformation. - casting, order, dtype, subok (optional): Control the behavior of casting and memory ordering. Returns: - angle_rad (array): Angle(s) converted to radians."
  },
  "numpy.ravel": {
    "new_func": "flatten_array",
    "description": "Transform a multi-dimensional array into a contiguous 1-D array. If a copy is necessary, one will be made to ensure a contiguous memory layout. The returned array will maintain the same data type as the input structure."
  },
  "numpy.ravel_multi_index": {
    "new_func": "multi_index_to_offset",
    "description": "Transform a tuple of index arrays into a single array of indices in a flattened version of an array with specified dimensions, while respecting specified boundary modes for out-of-bounds indices."
  },
  "numpy.real": {
    "new_func": "extract_real_component",
    "description": "Extract the non-imaginary part of an array with complex numbers, resulting in an array of the same shape where each element is the real part of the corresponding element in the input array."
  },
  "numpy.real_if_close": {
    "new_func": "conditional_real_converter",
    "description": "Convert an array with complex numbers to an array of real numbers if the imaginary parts are within a specified tolerance from zero, otherwise, return the original array."
  },
  "numpy.recarray": {
    "new_func": "structured_field_array",
    "description": "Create an array with structured data types, enabling field access using attribute-style access as well as traditional dictionary-style. This facilitates treating arrays as tables with columns that can be accessed as attributes."
  },
  "numpy.record": {
    "new_func": "field_accessible_scalar",
    "description": "Represents a scalar that allows access to its fields as if they were attributes. This scalar is akin to a single element of a structured array. It possesses attributes and methods similar to an array, enabling operations like field retrieval, complex number manipulation, serialization, and more. It also allows for attribute-like access to its fields."
  },
  "numpy.reciprocal": {
    "new_func": "multiplicative_inverse",
    "description": "Computes the multiplicative inverse of each element in the input collection. Specifically, it performs the calculation of 1 divided by each element. The function accepts an array-like input and returns an array where each element is the inverse of the corresponding element in the input. An optional output array can be provided to store the result."
  },
  "numpy.reshape": {
    "new_func": "alter_dimensions",
    "description": "Modifies the dimensions of an existing array without altering its data. It takes an array-like structure and a new shape, which should be compatible with the original size of the array. It can also take an order parameter that determines the read and write order of the elements. The result is a new array with the specified layout, potentially as a view if no data copy is necessary."
  },
  "numpy.remainder": {
    "new_func": "division_residue",
    "description": "Calculates the residue of division for corresponding elements in two array-like inputs. It is equivalent to the modulus operation in Python and returns the result with the same sign as the divisor. This operation is not to be confused with the mathematical or C programming remainder operations. The result is an array containing the division residues element-wise."
  },
  "numpy.repeat": {
    "new_func": "duplicate_elements",
    "description": "Creates a new array by replicating each element of the input array a certain number of times, specified by the repeats argument. The repetition can occur along a specified axis or can default to a flat structure. The output is an array that has the same shape as the input, except for the dimension along the specified axis which is multiplied by the number of repetitions."
  },
  "numpy.resize": {
    "new_func": "array_expansion",
    "description": "Creates a new array with the desired dimensions. If the target size is larger, the content of the original array is replicated to populate the new array. If the array needs to be reduced, only a portion of the original array is retained. This method does not simply add empty space around the original array; it fills in additional space by repeating the array's contents in a row-major (C-like) order. It is not suitable for applications that require interpolation or treating axes distinctly, such as image scaling."
  },
  "numpy.result_type": {
    "new_func": "unified_data_type",
    "description": "Determines the data type that would result from combining multiple input arrays and data types, according to the rules for data type coercion. This function is useful for understanding what data type will result from operations involving different data types. It takes into account both the kind and the size of the data types involved, ensuring that the result preserves the precision and scale of the inputs."
  },
  "numpy.roll": {
    "new_func": "circular_shift",
    "description": "Cyclically displaces elements of an array along a specified axis, with elements that move past the end of the array reappearing at the beginning. This operation is useful for periodic data or for moving elements while maintaining the structure of the array. The displacement can be specified for multiple axes simultaneously by providing tuples for the shift amount and the corresponding axes."
  },
  "numpy.right_shift": {
    "new_func": "bitwise_shrink",
    "description": "Performs a binary shift operation that transfers the bits of an integer array towards the less significant side by a specified number of places. This operation effectively divides the array elements by powers of two. It is particularly useful for bit manipulation tasks and low-level integer operations."
  },
  "numpy.rint": {
    "new_func": "nearest_integer",
    "description": "Adjusts each element of the input array to the closest whole number. This function respects the half-way rounding rule, where values equidistant from two integers are rounded towards the nearest even number. The result has the same shape and type as the input array and can be useful in rounding operations where fractional parts are not needed."
  },
  "numpy.require": {
    "new_func": "ensure_compliance",
    "description": "Transforms an input into an array that adheres to the specified conditions and data type. This is particularly useful for interfacing with external code that expects arrays with certain properties. Parameters: - input_object: The entity to be transformed into the array. - target_dtype: Desired data type for the array, or None to keep existing data type. - conditions: String or list of strings indicating desired properties such as memory order or writability. - reference_like: Optional. An array-like reference for creating compatible array objects. Returns: - compliant_array: An array matching the requested type and properties."
  },
  "numpy.rot90": {
    "new_func": "quarter_turn",
    "description": "Performs a 90-degree rotation of a multi-dimensional array in a specified plane. Parameters: - multi_array: An array with two or more dimensions. - rotation_count: The number of 90-degree rotations to apply. - rotation_plane: A tuple indicating the plane in which to rotate the array. Returns: - rotated_view: A view of the original array after applying the specified rotation."
  },
  "numpy.rollaxis": {
    "new_func": "axis_relocator",
    "description": "Shifts a specified axis of an array to a new position, while preserving the order of other axes. Parameters: - input_array: The array whose axes will be reordered. - target_axis: The axis to be moved. - new_position: The position where the axis is intended to be placed. Returns: - repositioned_array: A view of the input array with the axis relocated as specified."
  },
  "numpy.round": {
    "new_func": "decimal_adjuster",
    "description": "Alters the precision of an array's elements to a specified number of decimal places. Parameters: - input_data: The array whose elements are to be modified. - precision: Optional number of decimal places to which elements are rounded. Can be negative. - alternate_output: Optional array to store the result. Must be of the same shape as the expected output. Returns: - adjusted_array: An array with elements rounded to the given precision."
  },
  "numpy.s_": {
    "new_func": "index_builder",
    "description": "Facilitates the creation of complex index combinations for array slicing. Parameters: - make_tuple: If set to True, the result is always returned as a tuple. Returns: - index_tuple: A tuple of slice objects that can be used in advanced indexing of arrays."
  },
  "numpy.save": {
    "new_func": "persist_binary",
    "description": "Write an array to a binary file in a specific format. Parameters: - destination: (file, str, or pathlib.Path) Destination file or filename. If a string or Path is provided, a .npy extension is added if not present. - data: (array_like) Data to be written to the file. - permit_pickle: (bool, optional) Allows saving object arrays with pickling. Default is True. - ensure_compat: (bool, optional) Ensures that the pickle is compatible with Python 2 if True. Default is True. Returns: None."
  },
  "numpy.savetxt": {
    "new_func": "export_textual",
    "description": "Commit an array to a text file. Parameters: - target: (filename, file handle, or pathlib.Path) Destination file, automatically saved in gzip format if the filename ends in .gz. - data: (1D or 2D array_like) Data to be saved. - format_spec: (str or sequence of strs, optional) Format specification for each element in data. Default is '%.18e'. - column_sep: (str, optional) Separator between columns. Default is ' '. - line_sep: (str, optional) Separator between lines. Default is '\\n'. - prologue: (str, optional) Text to be written at the beginning of the file. - epilogue: (str, optional) Text to be written at the end of the file. - comment_prefix: (str, optional) Prefix for comments in prologue and epilogue. Default is '# '. - file_encoding: ({None, str}, optional) Encoding for the file. Default is 'latin1'. Returns: None."
  },
  "numpy.savez": {
    "new_func": "archive_arrays",
    "description": "Archive multiple arrays into a single file in an uncompressed format. Parameters: - destination: (file, str, or pathlib.Path) File or filename for data storage. Appends .npz extension if not present. - positional_args: (optional) Arrays to save without keywords will be named sequentially as 'arr_0', 'arr_1', etc. - keyword_args: (optional) Named arrays to save, with each array's keyword as its filename in the archive. Returns: None."
  },
  "numpy.savez_compressed": {
    "new_func": "archive_arrays_compressed",
    "description": "Store multiple arrays into a single compressed archive file. Parameters: - destination: (file, str, or pathlib.Path) File or filename for data storage. Appends .npz extension if not present. - positional_args: (optional) Arrays to save without keywords will be named sequentially as 'arr_0', 'arr_1', etc. - keyword_args: (optional) Named arrays to save, with each array's keyword as its filename in the compressed archive. Returns: None."
  },
  "numpy.searchsorted": {
    "new_func": "find_insertion_indices",
    "description": "Determine indices to insert elements to maintain a sorted sequence. Parameters: - sorted_sequence: (1-D array_like) Must be sorted in ascending order unless sorter is provided. - values: (array_like) Values to insert into sorted_sequence. - insert_side: ({'left', 'right'}, optional) Specifies the side of the insertion point. 'left' for the first suitable location, 'right' for the last. Default is 'left'. - sequence_sorter: (1-D array_like, optional) Array of indices that sort the sorted_sequence. Only required if sorted_sequence is not already sorted. Returns: indices: (int or array of ints) Insertion points with the same shape as values or a single integer if values is a scalar."
  },
  "numpy.select": {
    "new_func": "conditional_selector",
    "description": "Construct an array by choosing elements from a series of arrays based on corresponding true values in a list of boolean arrays. If none of the conditions are met, a specified default value is used. Parameters: - condition_list: list of boolean arrays that determine the source for each element. - choice_list: list of arrays from which to source elements. Length must be equal to condition_list. - default_value: scalar value to use when no condition is met. Optional, defaults to 0. Returns: - selected_array: an array with elements drawn from choice_list based on condition_list."
  },
  "numpy.set_printoptions": {
    "new_func": "configure_display_format",
    "description": "Adjust the formatting parameters for the visual representation of arrays. This affects how arrays are printed to the console. Parameters include number of digits for precision, threshold for summarization, items to display at the edge of each dimension, linewidth, suppression of small values, string representation of NaN and Infinity, sign option, and custom formatters for different data types. Returns: None."
  },
  "numpy.roots": {
    "new_func": "polynomial_roots",
    "description": "Calculate the zeros of a polynomial equation with coefficients specified. The array provided contains the coefficients in descending powers of the variable. Parameters: - coefficients: A rank-1 array of polynomial coefficients. Returns: - zeros: An array containing the calculated zeros of the polynomial."
  },
  "numpy.setbufsize": {
    "new_func": "adjust_ufunc_buffer",
    "description": "Alter the buffer size for universal functions (ufuncs). This can affect performance for ufunc calculations. Parameters: - buffer_size: Integer specifying the new buffer size. Returns: None."
  },
  "numpy.setdiff1d": {
    "new_func": "unique_complement",
    "description": "Identify elements present in the first input array but not in the second. The result can optionally be sorted if the arrays are not assumed to contain unique elements. Parameters: - first_array: Input array to compare against. - second_array: Array containing elements to exclude. - unique_assumption: Boolean indicating if the input arrays are assumed to have unique elements, which can optimize computation. Returns: - complement: A 1D array of elements unique to the first input array."
  },
  "numpy.seterr": {
    "new_func": "adjust_floating_exceptions",
    "description": "Adjust the behavior for handling floating-point arithmetic anomalies. It allows specifying how to treat division by zero, overflow, underflow, and invalid operations. Parameters: - all: Optional parameter to set the treatment for all types of anomalies. - divide: Treatment for division by zero. - over: Treatment for result too large to be expressed. - under: Treatment for result too small, losing precision. - invalid: Treatment for an inexpressible number result. Returns: - old_settings: A dictionary with the previous settings."
  },
  "numpy.setxor1d": {
    "new_func": "symmetric_difference_sorted",
    "description": "Calculate the sorted symmetric difference of two input arrays, providing unique values present in only one array and not the other. Parameters: - ar1: First input array. - ar2: Second input array. - assume_unique: If True, the input arrays are considered to be unique, which can speed up the calculation. Returns: - setxor1d: A sorted 1D array of the symmetric difference."
  },
  "numpy.shape": {
    "new_func": "dimensions_tuple",
    "description": "Obtain the dimensions of the given array as a tuple, where each element represents the size of the array along that dimension. Parameters: - a: The array to determine the dimensions of. Returns: - shape: A tuple with the size of each dimension."
  },
  "numpy.seterrcall": {
    "new_func": "define_error_callback",
    "description": "Specify a custom function or an object with a write method to handle floating-point errors when the error mode is set to 'call' or 'log'. Parameters: - func: A callable to be used when 'call' mode is active or an object with a 'write' method for 'log' mode. Returns: - h: The previous error handler."
  },
  "numpy.shares_memory": {
    "new_func": "overlapping_storage",
    "description": "Check if two arrays have overlapping memory blocks. This function can be resource-intensive and might exhibit exponential time complexity based on input. Parameters: - a: First array to check. - b: Second array to check. - max_work: An optional integer representing the effort to invest in checking overlap. Special values like MAY_SHARE_EXACT or MAY_SHARE_BOUNDS can be used to control the behavior. Returns: - out: Boolean indicating if memory is shared. Exceptions: - TooHardError: Raised if the problem exceeds the specified max_work value."
  },
  "numpy.show_config": {
    "new_func": "display_build_details",
    "description": "Presents the libraries and system particulars utilized for the construction and current operation of the library. Parameters: - mode (string, optional): Specifies the presentation format of the configuration details. Accepts 'stdout' to output to console or 'dicts' to return a dictionary object. Returns: - out (dictionary, None): If mode is 'dicts', a dictionary object is returned, otherwise None."
  },
  "numpy.signbit": {
    "new_func": "is_negative_indicator",
    "description": "Determines if each element of the input array has its negative bit set, indicating a negative value. Parameters: - x (array_like): The input values. - out (array, optional): A location for storing the result. Must be broadcast-compatible with the input array. Default is a new array. - where (array_like, optional): A boolean array that specifies where to apply the operation. Returns: - result (array of bool): An array of boolean values, where True indicates a negative value. Scalars return a single boolean value."
  },
  "numpy.sign": {
    "new_func": "numeric_polarity",
    "description": "Provides an element-wise determination of the polarity of input values, indicating whether they are positive, negative, or zero. Parameters: - x (array_like): The values to evaluate. - out (array, optional): A location for the result, with a compatible shape to the input array. Default is a new array. - where (array_like, optional): Condition array to apply operation. Returns: - y (array): An array with the polarity of each element, returning -1, 0, or 1 for negative, zero, or positive values respectively."
  },
  "numpy.sin": {
    "new_func": "circular_ratio",
    "description": "Calculates the trigonometric sine of angle measurements provided in radians for each element in the input array. Parameters: - x (array_like): Angles in radians. - out (array, optional): A location to store the computed values, must be compatible with the input shape. Default is a new array. - where (array_like, optional): A condition specifying where to perform the operation. Returns: - y (array_like): The sine value of each input element. If the input is scalar, a scalar is returned."
  },
  "numpy.show_runtime": {
    "new_func": "resource_inspection",
    "description": "Outputs information about system resources, including intrinsic support and the BLAS/LAPACK libraries in use. Parameters: None Returns: None - Prints information directly to the console."
  },
  "numpy.sinc": {
    "new_func": "normalized_sinusoidal_interpolation",
    "description": "Calculates the normalized cardinal sine function of the input array. This mathematical function generates a value of one at zero and oscillates according to the sine of pi times the input value, divided by the input value itself, for all other inputs. This operation is commonly utilized in digital signal processing to prevent aliasing and to create resampling filters. The function accepts an array of values and returns an array of the same shape with the cardinal sine of each element computed."
  },
  "numpy.sinh": {
    "new_func": "hyperbolic_sine_transform",
    "description": "Performs an element-wise calculation of the hyperbolic sine of the input values. This function mirrors the shape of a hanging cable or chain, known as a catenary, and is computed as the difference between the exponential function of the input and its inverse, divided by two. It can alternatively be represented as the imaginary part of the sine of an imaginary argument. An output array can be specified, otherwise a new array is allocated. The function returns an array of hyperbolic sine values, matching the shape of the input."
  },
  "numpy.size": {
    "new_func": "count_elements",
    "description": "Determines the total count of elements within the provided array, with an option to specify counting along a particular axis. If no axis is specified, it returns the total number of elements across all dimensions. The function can be useful for understanding the structure and size of data arrays. The result is an integer representing the count of elements."
  },
  "numpy.sort": {
    "new_func": "ordered_sequence",
    "description": "Produces a copy of the provided array with its elements arranged in ascending order. The ordering can be performed along a specific axis or globally on a flattened version of the array. Several sorting algorithms are available, including quicksort, mergesort, heapsort, and a stable sort that preserves the relative order of equivalent elements. The sorted result maintains the original data type and shape of the array."
  },
  "numpy.sort_complex": {
    "new_func": "complex_number_sequencer",
    "description": "Organizes a complex-valued array by arranging its elements based on the ascending order of their real parts and, in case of a tie, their imaginary parts. This function ensures the returned array consists of complex numbers in a sequence where each number follows its predecessor based on the defined ordering. The output is a complex array with elements sorted as described."
  },
  "numpy.spacing": {
    "new_func": "adjacent_interval",
    "description": "Calculate the smallest representable increment at the location of the provided value, effectively measuring the precision of the floating-point representation for that value. Parameters: - value (array_like): Values to compute the precision increment. - out (array, optional): Alternative output array in which to place the result. It must have a shape that the input broadcasts to. - where (array_like, optional): Condition over the input to determine where the operation is applied. - **kwargs: Additional arguments for advanced usage. Returns: - increments (array or scalar): The precision increment of the input values. A scalar is returned if the input is a scalar."
  },
  "numpy.sqrt": {
    "new_func": "elementwise_root",
    "description": "Compute the non-negative square root of each element in the input array. Parameters: - values (array_like): Input values to compute the square root for. - out (array, optional): Alternative output array to store the result. It must have a shape that the input broadcasts to. - where (array_like, optional): Condition to apply the operation. - **kwargs: Additional arguments for advanced usage. Returns: - roots (array): An array of the non-negative square roots of the input array elements. The output has the same shape as the input and contains complex numbers if any input is negative."
  },
  "numpy.split": {
    "new_func": "segment",
    "description": "Divide an array into multiple segments along a specified axis. Parameters: - source (array): The array to be divided. - indices_or_sections (int or 1-D array): Determines how to divide the array. If an integer is provided, the array is divided into that many equal segments. If it is an array of sorted integers, they specify the division points. - axis (int, optional): The dimension along which to divide the array. Returns: - segments (list of arrays): A list of arrays as segments of the input array."
  },
  "numpy.stack": {
    "new_func": "axis_combiner",
    "description": "Merge a sequence of arrays along an additional axis. Parameters: - sequence (sequence of array_like): Sequence of arrays with the same shape to be combined. - axis (int, optional): Index of the new axis in the result. - out (array, optional): Alternative output array for the result. Must match the expected shape. - dtype (str or dtype, optional): Desired data type for the output array. - casting (str, optional): Rules for data type casting. Returns: - combined (array): The combined array with an additional dimension."
  },
  "numpy.square": {
    "new_func": "elementwise_product",
    "description": "Calculate the element-wise product of the input with itself. Parameters: - values (array_like): Input data for which the element-wise square is computed. - out (array, optional): Alternative array to store the result. It must have a shape that the input broadcasts to. - where (array_like, optional): Condition over the input to determine where the operation is applied. - **kwargs: Additional arguments for advanced usage. Returns: - product (array or scalar): The element-wise square of the input array."
  },
  "numpy.squeeze": {
    "new_func": "eliminate_singleton_dimensions",
    "description": "Reduces the dimensions of the input array by removing axes with a single element without altering the data. Parameters: - input_data (array_like): The array from which to remove singleton axes. - axes (None, int, or tuple of ints, optional): Specifies which single-length axes to remove. If None, all single-length axes are eliminated. Returns: - compacted_array (array): Array with the same data as the input, but with specified or all singleton dimensions removed. Raises: - ValueError: If any axis specified is not of length 1."
  },
  "numpy.std": {
    "new_func": "calculate_deviation",
    "description": "Evaluates the dispersion measure around the mean of the array elements. Parameters: - input_data (array_like): Values to compute the dispersion measure. - axes (None, int, or tuple of ints, optional): Axis or axes to calculate over. Default is to calculate over the flattened array. - result_type (dtype, optional): Desired data-type for the result. Defaults to the data type of the input array for floating-point inputs and float64 for integer inputs. - output_array (array, optional): An alternate array to store the result. - delta_degrees_freedom (int or float, optional): The divisor modification term, where the divisor is (N - delta_degrees_freedom) with N being the number of elements. - keep_dimensions (bool, optional): Whether to maintain reduced axes with size one in the result. - conditions (array_like of bool, optional): Specifies elements to include in the calculation. Returns: - dispersion_measure (array): An array holding the calculated dispersion measure."
  },
  "numpy.subtract": {
    "new_func": "elementwise_difference",
    "description": "Computes the element-by-element subtraction of two arrays. Parameters: - minuend, subtrahend (array_like): Input arrays to be subtracted. - destination (array, optional): Array to store the result. - conditions (array_like, optional): Boolean mask determining where to perform the subtraction. Returns: - result (array): An array containing the element-wise differences of the inputs."
  },
  "numpy.sum": {
    "new_func": "aggregate_total",
    "description": "Calculates the total sum of array elements over the specified axes. Parameters: - elements (array_like): The input elements to sum. - axes (None, int, or tuple of ints, optional): Axes to sum across. Default sums over all elements. - result_type (dtype, optional): Data type for the return array and accumulator. - destination (array, optional): Alternate output array for the result. - keep_dimensions (bool, optional): Whether to keep reduced axes as dimensions with size one. - initial_value (scalar, optional): Starting value for the sum. - inclusion_conditions (array_like of bool, optional): Elements to include in the sum. Returns: - summed_values (array): Array with sum totals, with the same shape as the input without the specified axes."
  },
  "numpy.take": {
    "new_func": "extract_elements",
    "description": "Selects and retrieves elements from the input array along the chosen axis based on the provided indices. Parameters: - source_array (array_like): Array to extract elements from. - chosen_indices (array_like): Indices of the elements to extract. - chosen_axis (int, optional): Axis over which to select elements. Defaults to the flattened array if None. - target_array (array, optional): Array to store the extracted elements. - mode (str, optional): How to handle indices that are out of bounds ('raise', 'wrap', or 'clip'). Returns: - extracted_elements (array): Array of the extracted elements."
  },
  "numpy.swapaxes": {
    "new_func": "exchange_axes",
    "description": "Exchange two specified dimensions of a given array. This function allows reordering of the array axes by providing the indices of two dimensions that should be swapped. The resulting array is a reshaped view of the original data whenever possible, otherwise a new array is allocated.\nParameters:\n- array: array_like, the input array whose axes are to be swapped.\n- first_dim: int, index of the first dimension to be exchanged.\n- second_dim: int, index of the second dimension to be exchanged.\nReturns:\n- reshaped_array: array, an array with two of its dimensions exchanged, based on the input indices."
  },
  "numpy.tan": {
    "new_func": "circular_tangent",
    "description": "Calculate the tangent of each element in the input array, where the tangent function is defined as the ratio of the sine to the cosine of the input values. This operation is performed element-wise.\nParameters:\n- input_array: array_like, the input array containing angles for which the tangent is to be computed.\n- output_array: array, optional, an alternative output array in which to place the result. It must have a shape that the inputs broadcast to.\n- where: array_like, optional, condition array that chooses where the operation is performed when broadcasting.\n- kwargs: additional keyword arguments.\nReturns:\n- result: array, an array with the tangent of each element of the input array."
  },
  "numpy.take_along_axis": {
    "new_func": "extract_by_index",
    "description": "Retrieve elements from the source array by matching indices along a specified axis. This function iterates over 1d segments aligned with the given axis in both the source and indices arrays, using the latter to select elements from the former.\nParameters:\n- source: array, array from which to extract elements.\n- indices: array, array of indices to select from the source, must be broadcastable against the source.\n- axis: int, the axis along which to select elements.\nReturns:\n- result: array, the array of selected elements."
  },
  "numpy.tanh": {
    "new_func": "hyperbolic_tangent",
    "description": "Calculate the hyperbolic tangent of each element in the input array, computed element-wise. This function returns the ratio of the hyperbolic sine to the hyperbolic cosine of the input values.\nParameters:\n- input_array: array_like, the input array containing values for which the hyperbolic tangent is to be computed.\n- output_array: array, optional, an alternative output array in which to place the result. It must have a shape that the inputs broadcast to.\n- where: array_like, optional, condition array that chooses where the operation is performed when broadcasting.\n- kwargs: additional keyword arguments.\nReturns:\n- result: array, an array with the hyperbolic tangent of each element of the input array."
  },
  "numpy.tensordot": {
    "new_func": "multidimensional_inner_product",
    "description": "Calculate the sum of products over specified axes of two arrays. This function contracts the input arrays over a single shared dimension or multiple dimensions specified by the user.\nParameters:\n- tensor1: array_like, first input array to be contracted.\n- tensor2: array_like, second input array to be contracted.\n- axes_spec: int or (2,) array_like, which axes to contract over. If an integer, it specifies the number of last dimensions of the first array and the number of first dimensions of the second array to sum over. If an array_like, it should contain two sequences specifying the axes of the first and second array to contract over.\nReturns:\n- result: array, the contracted array resulting from the tensor dot product."
  },
  "numpy.tile": {
    "new_func": "array_amplify",
    "description": "Creates a new array by replicating the given array for a certain number of times along each dimension as specified. If the replication factor has more dimensions than the array, the array is expanded with new axes at the start. Conversely, if the array has more dimensions than the replication factor, the latter is expanded with ones at the start to match the array's dimensions."
  },
  "numpy.transpose": {
    "new_func": "axis_reorder",
    "description": "Modifies the structure of an array by altering the order of its axes. For multi-dimensional arrays, it can rearrange the axes based on a specified sequence, or reverse their order if no sequence is given."
  },
  "numpy.trace": {
    "new_func": "sum_diagonal",
    "description": "Calculates the cumulative sum of elements along the array's diagonals. For a two-dimensional array, it returns the sum of elements along the specified diagonal. For higher-dimensional arrays, it chooses two axes to form a 2D slice and computes the sum along the diagonals of these slices."
  },
  "numpy.tril": {
    "new_func": "lower_triangle_extract",
    "description": "Generates a copy of a multi-dimensional array with elements located above a certain diagonal set to zero, effectively extracting the lower triangular part of the array."
  },
  "numpy.tri": {
    "new_func": "unit_lower_triangle",
    "description": "Produces an array with a specified number of rows and columns, filled with ones at and below a specified sub-diagonal, and zeros elsewhere, forming a lower triangular matrix."
  },
  "numpy.tril_indices_from": {
    "new_func": "lower_triangle_positions_from",
    "description": "Retrieve the positions of elements in the sub-diagonal region of a square matrix. Parameters: - matrix (array_like): The matrix from which to derive indices. - diagonal_offset (int, optional): The specific diagonal where the sub-diagonal region starts. Defaults to 0, which represents the main diagonal. Returns: - row_indices, col_indices (tuple of arrays): The row and column indices of the elements in the specified lower triangular part of the matrix."
  },
  "numpy.tril_indices": {
    "new_func": "lower_triangle_positions",
    "description": "Obtain the coordinates for elements in the sub-diagonal part of a matrix with dimensions (rows, columns). Parameters: - rows (int): Number of rows in the matrix. - diagonal_offset (int, optional): The diagonal below which the indices are to be returned. - columns (int, optional): Number of columns in the matrix; defaults to the same as rows if not specified. Returns: - indices (tuple of arrays): A pair of arrays, each containing the row and column indices for the lower triangular part of the matrix."
  },
  "numpy.triu": {
    "new_func": "upper_triangle_extract",
    "description": "Generate a copy of the input array with all the elements below the specified diagonal set to zero. If the input is higher than two-dimensional, the function will be applied to the last two axes. Parameters: - matrix (array_like): Input array from which the upper triangular part is extracted. - diagonal_offset (int, optional): Position of the diagonal relative to which the zeroing of elements is determined. Returns: - result (array): A modified array with the same dimensions as the input, containing only the upper triangular elements."
  },
  "numpy.trim_zeros": {
    "new_func": "strip_zero_padding",
    "description": "Remove zeros from the beginning and/or end of a one-dimensional array or sequence. Parameters: - sequence (1-D array or sequence): The input data to be trimmed. - trim_direction (str, optional): String indicating whether to remove zeros from the 'front', 'back', or 'both' ends of the array. Defaults to 'both'. Returns: - trimmed_sequence (1-D array or sequence): The input sequence with leading and/or trailing zeros removed, preserving the original data type."
  },
  "numpy.true_divide": {
    "new_func": "element_wise_quotient",
    "description": "Perform element-by-element division of input arrays, broadcasting them as necessary. Parameters: - dividend (array_like): Array to be divided. - divisor (array_like): Array by which to divide. - output (array, None, or tuple, optional): An array or a tuple of arrays to store the result in. - condition (array_like, optional): A boolean array that specifies where the division should be performed; defaults to True everywhere. - kwargs: Additional arguments to control casting, order, subok, etc. Returns: - quotient (array or scalar): An array containing the divided result, or a scalar if both inputs are scalars."
  },
  "numpy.trunc": {
    "new_func": "integer_clipper",
    "description": "This function returns an array with the integral part of each element, effectively removing any fractional digits by truncation towards zero.\nParameters:\n- x (array_like): Input data.\n- out (array, optional): Alternative output array in which to place the result. It must have the same shape as the expected output.\n- where (array_like, optional): A boolean array that specifies where to apply the operation.\n- **kwargs: Additional arguments for advanced usage.\nReturns:\n- y (array or scalar): The result of truncation operation on the input array, with the same shape as x."
  },
  "numpy.typename": {
    "new_func": "data_kind_describer",
    "description": "This function provides a textual description corresponding to specified data type codes.\nParameters:\n- char (str): The data type code to be described.\nReturns:\n- out (str): Textual description of the data type code."
  },
  "numpy.ufunc": {
    "new_func": "array_element_operator",
    "description": "This class represents operations that execute on an element-by-element basis across arrays. It supports broadcasting and can return multiple outputs.\nParameters:\n- *x (array_like): Input arrays for the operation.\n- out (array, optional): Alternative output array(s) where the result is placed.\n- where (array_like, optional): Condition over the input for selective operation.\n- **kwargs: Additional keyword arguments.\nReturns:\n- r (array or tuple of array): The result of the operation with the same shape as the broadcasted input arrays."
  },
  "numpy.triu_indices_from": {
    "new_func": "upper_triangle_locator",
    "description": "This function returns the coordinates for the elements in the upper triangle of a square array, optionally starting from a specified diagonal.\nParameters:\n- arr (array): Input array with shape (N, N).\n- k (int, optional): Diagonal offset.\nReturns:\n- tuple (shape(2) of array): Two arrays representing the row and column indices of the upper-triangular elements."
  },
  "numpy.union1d": {
    "new_func": "sorted_merge_unique",
    "description": "This function computes the sorted, unique values that are present in any of the two input one-dimensional arrays.\nParameters:\n- ar1, ar2 (array_like): Input arrays, which will be flattened if not one-dimensional.\nReturns:\n- array: One-dimensional array of unique, sorted values from both input arrays."
  },
  "numpy.triu_indices": {
    "new_func": "upper_triangle_coords",
    "description": "Retrieve the coordinates for the upper-tier of a 2-dimensional square or rectangular grid. Parameters: - dimension: int, The size of the square grid, or number of rows in a rectangular grid. - offset: int, optional, The number of diagonals above (positive) or below (negative) the main diagonal to start from. Default is 0. - columns: int, optional, Number of columns in a rectangular grid. Defaults to dimension if not provided. Returns: - coordinates: tuple of arrays, Two arrays representing the row and column indices that can be utilized to isolate the specified upper-tier section of a 2D grid."
  },
  "numpy.unique": {
    "new_func": "distinct_elements",
    "description": "Identify distinct items within an array and optionally return additional related arrays. Parameters: - input_array: array_like, The input data to process. - return_index: bool, optional, If True, returns the indices that result in the distinct array. - return_inverse: bool, optional, If True, returns the indices to reconstruct the input array from the distinct array. - return_counts: bool, optional, If True, returns the frequencies of each distinct item. - axis: int or None, optional, Specifies the axis to process. If None, the input is flattened. - consider_nan_equal: bool, optional, If True, treats NaN values as equal. Returns: - distinct_array: array, The sorted distinct values. - first_occurrence_indices: array, optional, The indices of first occurrences of the distinct values. - reconstruction_indices: array, optional, The indices to recreate the input array from the distinct array. - element_counts: array, optional, The frequencies of each distinct value within the input array."
  },
  "numpy.unique_values": {
    "new_func": "singular_elements",
    "description": "Produce an array containing only the non-repeating elements from the input array. Parameters: - input_array: array_like, The array to be processed which will be flattened if not already 1-dimensional. Returns: - output: array, An array of non-repeating elements."
  },
  "numpy.unique_all": {
    "new_func": "exhaustive_distinct_elements",
    "description": "Identify all non-repeating items in an array, along with their occurrence counts, original indices, and reconstruction indices. Parameters: - input_array: array_like, The array to examine, which will be flattened if not already 1-dimensional. Returns: - result: namedtuple, Contains the following information: 'values' - Non-repeating elements, 'indices' - Initial indices for each element, 'inverse_indices' - Indices to rebuild the original array, 'counts' - Frequencies for each element."
  },
  "numpy.unique_inverse": {
    "new_func": "unique_rebuilder",
    "description": "Discover non-repeating items in an array and indices to reconstruct the original array. Parameters: - input_array: array_like, The array to process, which will be flattened if not already 1-dimensional. Returns: - result: namedtuple, Holds the non-duplicate elements ('values') and the indices ('inverse_indices') that can be used to regenerate the input array."
  },
  "numpy.unique_counts": {
    "new_func": "distinct_elements_tally",
    "description": "Identifies the distinct elements within a 1-D array and tallies their occurrences. Parameters: - x: array_like, The input array to analyze, will be flattened if not already 1-D. Returns: - out: namedtuple, The result includes two fields: 'values' - The distinct elements identified. 'counts' - The number of times each distinct element appears."
  },
  "numpy.unpackbits": {
    "new_func": "binary_decomposition",
    "description": "Decomposes each element of an array of unsigned 8-bit integers into a binary representation. Parameters: - a: nd_array, uint8 type, The input array. - axis: int, optional, The dimension for decomposition. - count: int or None, optional, The number of bits to decompose. - bitorder: {'big', 'little'}, optional, The bit order in the output array. Returns: - unpacked: array, uint8 type, The binary-valued representation of the input array."
  },
  "numpy.unravel_index": {
    "new_func": "multi_dimensional_coordinates",
    "description": "Converts a flat index, or array of such indices, into a tuple of coordinate arrays based on a given shape. Parameters: - indices: array_like, An array of integer indices. - shape: tuple of ints, The dimensions of the array for the indices. - order: {'C', 'F'}, optional, Order of index interpretation. Returns: - unraveled_coords: tuple of array, Coordinate arrays corresponding to the indices."
  },
  "numpy.unwrap": {
    "new_func": "phase_correction",
    "description": "Applies phase adjustments to a signal to ensure that the difference between values does not exceed a given threshold. Parameters: - p: array_like, The input signal. - discont: float, optional, Maximum allowed discontinuity between values. - axis: int, optional, Axis along which to apply the correction. - period: float, optional, The range over which the input signal wraps. Returns: - out: array, The corrected signal."
  },
  "numpy.where": {
    "new_func": "conditional_selector",
    "description": "Selects elements from two arrays based on a boolean condition. Parameters: - condition: array_like, bool, The condition array. - x, y: array_like, Arrays from which to draw values. Must be broadcastable. Returns: - out: array, An array with elements from x where condition is True, and from y elsewhere."
  },
  "numpy.vectorize": {
    "new_func": "array_broadcast_mapper",
    "description": "Transforms a function to receive array inputs and broadcast them according to standard broadcasting rules. The transformed function processes elements as if applying the given function element-wise, supporting the same behavior as the built-in map function. The result is an array or a tuple of arrays, and the output data type can be predefined to avoid automatic determination based on the initial element of inputs. The function also allows for excluding certain arguments from broadcasting, supports caching of the first call, and can handle generalized input shapes based on a specified signature. Parameters: - pyfunc: Optional callable function to be transformed. - otypes: Optional data type specifier for the output. - doc: Optional documentation string for the transformed function. - excluded: Optional set specifying arguments to omit from transformation. - cache: Optional boolean to enable caching of the initial call. - signature: Optional signature for generalized input shapes. Returns: - out: Transformed callable that acts on array inputs."
  },
  "numpy.vsplit": {
    "new_func": "row_partitioner",
    "description": "Divides an input array into sub-arrays along the vertical axis based on specified indices or section counts. This operation is particularly useful for splitting data into smaller, row-based components. The function is a special case of a more general array splitting operation with a fixed axis of 0. Parameters: - ary: Array to be divided into sub-arrays. - indices_or_sections: Indices at which to split the array or number of equal sections to create. Returns: - sub_arrays: List of sub-arrays divided along the vertical axis."
  },
  "numpy.vstack": {
    "new_func": "row_sequencer",
    "description": "Joins a sequence of arrays along the vertical axis, effectively stacking them row-wise to create a single array. This operation is particularly useful when working with arrays that represent data in a tabular format with rows and columns. It is similar to array concatenation, but with a focus on vertical stacking. Parameters: - tup: Sequence of arrays with the same shape along all but the first axis. They must be compatible for stacking. - dtype: Optional data type for the output array. - casting: Optional casting rule for data types. Returns: - stacked: The vertically stacked array resulting from the combination of the input arrays."
  },
  "numpy.vdot": {
    "new_func": "complex_vector_product",
    "description": "Calculates the dot product of two one-dimensional vectors, handling complex numbers uniquely by taking the complex conjugate of the first argument before multiplication. This function differs from a standard dot product by flattening the input arrays prior to computation. It is intended for use with vectors and will not perform matrix multiplication. Parameters: - a: First one-dimensional input array. If complex, its conjugate is used. - b: Second one-dimensional input array. Returns: - output: The computed dot product, which can be an integer, float, or complex number based on the input array types."
  },
  "numpy.var": {
    "new_func": "dispersion_measure",
    "description": "Calculates the measure of spread in the data, which is the average of the squared deviations from the mean, providing an indication of the data's variability. The calculation can be performed over the entire dataset or along a specified axis and is customizable with degrees of freedom adjustments and data type specifications. Parameters: - a: Input array containing elements for variance computation. - axis: Optional axis or axes along which to compute. - dtype: Optional data type for computation. - out: Optional output array to place the result. - ddof: 'Delta Degrees of Freedom' affecting the divisor in the calculation. - keepdims: Optional boolean to maintain reduced axes. - where: Optional boolean array to specify elements to include. - mean: Optional precomputed mean value. - correction: Optional parameter analogous to ddof for Array API compatibility. Returns: - variance: The computed variance of the array elements."
  },
  "numpy.vecdot": {
    "new_func": "vector_inner_product",
    "description": "Calculate the inner product of two vectors, taking the complex conjugate of the first vector's elements if necessary. The operation is performed over the last axis of the input arrays by default, or along a specified axis.\nParameters:\n- x1 (array_like): First input vector.\n- x2 (array_like): Second input vector.\n- out (array, optional): Optional output array to store the result.\n- **kwargs: Additional keyword arguments for advanced usage.\nReturns:\n- y (array): The computed inner product of the two vectors. Returns a scalar if both inputs are one-dimensional.\nRaises:\n- ValueError: If the dimensions of the input arrays do not match or if scalars are passed as input."
  },
  "numpy.vander": {
    "new_func": "powers_matrix",
    "description": "Create a matrix where each column is an element-wise power of the input vector, with the power decreasing across the columns by default.\nParameters:\n- x (array_like): One-dimensional input array.\n- N (int, optional): The number of columns in the generated matrix. If not provided, a square matrix is returned.\n- increasing (bool, optional): Determines the ordering of the powers; increasing or decreasing from left to right.\nReturns:\n- out (array): The generated matrix with ordered powers of the input vector."
  },
  "numpy.zeros_like": {
    "new_func": "empty_clone",
    "description": "Generate a new array filled with zeros, mirroring the shape and data type of a reference array.\nParameters:\n- a (array_like): The reference array.\n- dtype (data-type, optional): Specifies the desired data type for the array; defaults to the data type of a.\n- shape (int or sequence of ints, optional): Specifies a new shape for the result.\n- **kwargs: Other options including memory layout and device placement.\nReturns:\n- out (array): An array of zeros with the same shape and type as the input array."
  },
  "numpy.zeros": {
    "new_func": "empty_grid",
    "description": "Create a new array with the specified shape, filled entirely with zeros.\nParameters:\n- shape (int or tuple of ints): Determines the shape of the new array.\n- dtype (data-type, optional): Desired data-type for the new array, with float64 as the default.\n- order ({'C', 'F'}, optional): Memory layout of the array; row-major or column-major.\nReturns:\n- out (array): An array of zeros with the given shape and data type."
  },
  "numpy.fft.fft": {
    "new_func": "harmonic_transform",
    "description": "Execute a one-dimensional discrete transformation of an array to its frequency domain, using the efficient algorithm commonly known as FFT.\nParameters:\n- a (array_like): Input array, possibly complex-valued.\n- n (int, optional): Specifies the length of the transformed axis of the result.\n- axis (int, optional): The axis over which to perform the transformation.\n- norm ({'backward', 'ortho', 'forward'}, optional): Normalization mode, with 'backward' as the default.\n- out (complex array, optional): An alternate output array to store the computed values.\nReturns:\n- out (complex array): The transformed array, showing frequency domain representation.\nRaises:\n- IndexError: If the specified axis exceeds array dimensions."
  },
  "numpy.fft.fft2": {
    "new_func": "two_dimensional_transform",
    "description": "Calculates the 2D discrete Fourier Transform of a complex or real matrix using a fast algorithm. This operation is typically applied to analyze the frequency components of signals represented in a two-dimensional grid. The transformation is applied primarily across the final two dimensions of an array by default, but can be adjusted to target different axes. Parameters: - input_array (array_like): A complex or real input matrix. - shape (sequence of ints, optional): Desired dimensions for each axis of the transformed output. - axes (sequence of ints, optional): Axes to perform the transformation on. - normalization (str, optional): Specifies the normalization mode. - output (complex array, optional): An array to store the result. Returns: - output (complex array): The 2D transformed array."
  },
  "numpy.fft.fftn": {
    "new_func": "multi_dimensional_transform",
    "description": "Executes the multi-dimensional discrete Fourier Transform on an array using an efficient algorithm. It is capable of transforming data across a specified number of axes in a multi-dimensional array. Users can determine the shape and axes of the transformation or let them be inferred from the input. Parameters: - input_array (array_like): A complex or real input array. - shape (sequence of ints, optional): Target dimensions for each axis of the output. - axes (sequence of ints, optional): Axes to perform the transformation on. - normalization (str, optional): Normalization mode specification. - output (complex array, optional): Pre-allocated array for the transformed result. Returns: - output (complex array): The transformed array across the specified axes."
  },
  "numpy.fft.fftfreq": {
    "new_func": "frequency_bins",
    "description": "Generates an array of sample frequencies for use with the Discrete Fourier Transform. The frequency bin centers are returned as floating-point values, represented in cycles per unit of the sampling spacing. Parameters: - window_length (int): Length of the DFT window. - sample_spacing (scalar, optional): The sample spacing rate's inverse. - device_placement (str, optional): Target device for array creation. Returns: - frequencies (array): An array containing the central frequencies of the DFT sample bins."
  },
  "numpy.fft.fftshift": {
    "new_func": "zero_frequency_centering",
    "description": "Rearranges the zero-frequency component to the central position of the spectrum array. This is commonly used for visualizing the Fourier Transform with the zero-frequency component in the middle of the spectrum image. The function can shift all axes or specified ones. Parameters: - input_array (array_like): The input spectrum array. - target_axes (int or shape tuple, optional): Axes to apply the shift. Returns: - shifted_array (array): The array with the zero-frequency component centered."
  },
  "numpy.fft.hfft": {
    "new_func": "real_spectrum_transform",
    "description": "Computes the Fourier Transform of a signal with Hermitian symmetry, implying a real-valued frequency spectrum. This function is particularly useful for signals where the frequency domain representation is real. Parameters: - input_array (array_like): Input array with Hermitian symmetry. - transform_length (int, optional): Length of the output transformed axis. - transform_axis (int, optional): Axis over which to compute the transform. - normalization (str, optional): Specifies the normalization mode. - output (array, optional): A pre-allocated array to hold the result. Returns: - output_array (array): The transformed array with a real frequency spectrum."
  },
  "numpy.fft.ifft": {
    "new_func": "inverse_spectral_reconstruction",
    "description": "Performs the one-dimensional inverse transformation of a complex-valued array from frequency to time domain, essentially reconstructing the original sequence from its spectral representation. This operation is the reverse process of the Fourier transform, effectively restoring the original signal if transformed and then inverted.\nParameters:\n- a (array_like): Input array, can be complex.\n- n (int, optional): Length of the transformed axis of the output. Determines the number of points to consider in the inversion.\n- axis (int, optional): The axis over which to perform the inversion. Defaults to the last axis.\n- norm (string, optional): Specifies the normalization mode, with possible values being 'backward', 'ortho', or 'forward'.\n- out (complex array, optional): A buffer for the result to be stored in, if provided.\nReturns:\n- out (complex array): The reconstructed input array along the specified axis."
  },
  "numpy.fft.ifftn": {
    "new_func": "multidimensional_spectral_inversion",
    "description": "Executes a multi-dimensional inverse transform of a complex-valued array from frequency domain back to spatial or temporal domains. This function is capable of transforming data across multiple axes simultaneously, thereby inverting an n-dimensional discrete Fourier Transform.\nParameters:\n- a (array_like): Complex input array.\n- s (sequence of ints, optional): Specifies the shape of the output along each transformed axis.\n- axes (sequence of ints, optional): The axes over which to compute the inverse transform.\n- norm (string, optional): Normalization mode, with options 'backward', 'ortho', or 'forward'.\n- out (complex array, optional): Container for the output result.\nReturns:\n- out (complex array): The inverse-transformed array with specified dimensions."
  },
  "numpy.fft.ifft2": {
    "new_func": "bidimensional_spectral_reconstruction",
    "description": "Computes the inverse transform of a 2D complex-valued array from frequency domain to spatial domain. This two-dimensional operation is typically applied to recover a bidimensional signal from its Fourier transformed state.\nParameters:\n- a (array_like): Complex input array.\n- s (sequence of ints, optional): Indicates the shape of the output for each axis.\n- axes (sequence of ints, optional): The axes over which to perform the inverse transformation, defaulting to the last two axes.\n- norm (string, optional): The normalization mode, with available options 'backward', 'ortho', or 'forward'.\n- out (complex array, optional): An array to store the result.\nReturns:\n- out (complex array): The array obtained after applying the inverse transformation on the specified axes."
  },
  "numpy.fft.ihfft": {
    "new_func": "hermitian_time_domain_reconstruction",
    "description": "Calculates the inverse Fast Fourier Transform of a real-valued signal that has symmetric properties in the frequency domain, often referred to as Hermitian symmetry. This function is particularly designed for signals that are real in the time domain.\nParameters:\n- a (array_like): Input array with Hermitian symmetry.\n- n (int, optional): Length of the inverse transform.\n- axis (int, optional): Axis over which to perform the inverse FFT.\n- norm (string, optional): Normalization mode with options including 'backward', 'ortho', and 'forward'.\n- out (complex array, optional): A buffer for the output array.\nReturns:\n- out (complex array): The time domain signal reconstructed from the input array."
  },
  "numpy.fft.ifftshift": {
    "new_func": "reverse_frequency_shift",
    "description": "Undoes the zero-frequency shift performed by the forward frequency shift function, effectively returning the zero-frequency component to its original position in the array. This is particularly useful for restoring the original ordering of data points in an array that has been frequency-shifted.\nParameters:\n- x (array_like): Input array to be shifted.\n- axes (int or shape tuple, optional): The axes along which the shift is to be applied. Defaults to shifting all axes.\nReturns:\n- y (array): The array with its elements shifted back to their original positions."
  },
  "numpy.fft.rfftfreq": {
    "new_func": "real_fourier_bin_centers",
    "description": "Calculates the center frequencies of bins in the real-valued Fourier transform. For a given window length and sample spacing, this function returns an array of frequencies corresponding to the centers of the bins used by the real-valued discrete Fourier transform. The array length will be half of the window length plus one. Frequencies are expressed in cycles per unit of the sample spacing. The Nyquist frequency component is included and is considered positive."
  },
  "numpy.fft.rfftn": {
    "new_func": "multi_dim_real_fourier_transform",
    "description": "Performs a multi-dimensional Fourier transform on an array with real number entries. This function applies the fast Fourier transform (FFT) across multiple dimensions. When no axes are specified, it transforms across all dimensions with the real-valued transform on the last axis and complex transforms on the others. The input can be cropped or zero-padded by specifying the shape of the transformed axes. The output will be a complex array containing the transformed coefficients."
  },
  "numpy.linalg.LinAlgError": {
    "new_func": "MatrixError",
    "description": "An exception that is raised when a linear algebra operation cannot proceed due to an issue with the input matrix, such as it being singular or not satisfying the requirements of the operation."
  },
  "numpy.linalg.cholesky": {
    "new_func": "triangular_decomposition",
    "description": "Performs a decomposition of a Hermitian, positive-definite matrix into a product of a lower or upper triangular matrix and its conjugate transpose. The input matrix must only consist of Hermitian or symmetric elements and be positive-definite for the decomposition to be valid. This operation is used for solving systems of linear equations where the matrix involved has the mentioned properties."
  },
  "numpy.linalg.cond": {
    "new_func": "matrix_stability_index",
    "description": "Calculates a value that measures the sensitivity of a matrix's inverse to changes in the matrix itself. The computation can be performed using different matrix norms, which are specified by an optional parameter. The resulting value is an indication of the numerical stability of solving systems of linear equations involving the matrix or inverting the matrix."
  },
  "numpy.linalg.cross": {
    "new_func": "vector_product",
    "description": "Calculate the vector product of pairs of 3-component vectors. For multi-dimensional arrays, the vector product is evaluated for each corresponding pair of vectors independently. The calculation is performed along a specified axis, which defaults to the last axis (-1). Parameters: - x1 (array_like): The first input array. - x2 (array_like): The second input array, must be compatible with x1. - axis (int, optional): The axis of x1 and x2 that contains the vectors. Default is -1. Returns: - out (array): An array of vector products."
  },
  "numpy.linalg.det": {
    "new_func": "matrix_determinant",
    "description": "Calculate the determinant of a square matrix or batch of square matrices. If the input is a batch of matrices, the determinants are computed for each matrix in the batch. Parameters: - a (array_like): An input array with the last two dimensions forming square matrices. Returns: - det (array_like): The determinant(s) of the input matrix (matrices)."
  },
  "numpy.linalg.diagonal": {
    "new_func": "matrix_diagonals",
    "description": "Retrieve specified diagonals from a matrix or a set of matrices. The function allows extraction of the main diagonal or an off-diagonal by specifying an offset. Parameters: - x (array_like): Input array with the last two dimensions forming matrices. - offset (int, optional): Specifies which diagonal to retrieve. Default is 0 (the main diagonal). Returns: - out (array): An array containing the extracted diagonals."
  },
  "numpy.linalg.eig": {
    "new_func": "square_eigen_solver",
    "description": "Derive the eigenvalues and corresponding right eigenvectors for each square matrix in the input array. The function handles complex and real matrices and returns a named tuple containing the eigenvalues and eigenvectors. Parameters: - a (array): Input array of square matrices. Returns: - eigenvalues (array): The eigenvalues for each matrix. - eigenvectors (array): The right eigenvectors for each matrix."
  },
  "numpy.linalg.eigvals": {
    "new_func": "matrix_eigenvalues",
    "description": "Compute the eigenvalues for each square matrix in the input array without computing the eigenvectors. Parameters: - a (array_like): An array of square matrices. Returns: - w (array): The computed eigenvalues for each matrix."
  },
  "numpy.linalg.multi_dot": {
    "new_func": "matrix_chain_product",
    "description": "Perform a series of matrix multiplications on two or more matrices, automatically determining the most efficient multiplication sequence to minimize computational cost. When the first argument is one-dimensional, it is interpreted as a horizontal vector, while a one-dimensional final argument is treated as a vertical vector. All other arguments should be two-dimensional matrices. The method can significantly expedite the computations depending on the dimensions of the involved matrices. Parameters: - arrays sequence of array_like: A sequence of matrices to be multiplied, where the first and last matrices can be 1-D to represent vectors and the others must be 2-D. - out array, optional: A location into which the result is stored. If provided, it must match the expected output shape and type. Added in version 1.19.0. Returns: - output array: The result of the chain matrix multiplication."
  },
  "numpy.linalg.pinv": {
    "new_func": "matrix_pseudoinverse",
    "description": "Calculate a matrix that represents the generalized inverse of the original matrix, based on its singular-value decomposition and considering all significant singular values. This inverse is particularly useful for solving linear least squares problems. This function is now capable of handling stacks of matrices as well. Parameters: - a (\u2026, M, N) array_like: The input matrix or stack of matrices to be inverted. - rcond (\u2026) array_like of float, optional: Threshold for small singular values, which are set to zero if they are less than or equal to rcond times the largest singular value. Defaults to 1e-15. - hermitian bool, optional: If true, the input matrix is assumed to be Hermitian, allowing for a more efficient computation. Defaults to false. Added in version 1.17.0. - rtol (\u2026) array_like of float, optional: An alternative to rcond following the Array API standard. Only one of rcond or rtol can be specified. If neither is provided, a default value of 1e-15 is used. Added in version 2.0.0. Returns: - B (\u2026, N, M) array: The pseudoinverse of the input matrix. If the input is a matrix object, the output will be too."
  },
  "numpy.linalg.outer": {
    "new_func": "vector_product",
    "description": "Calculate the outer product of two one-dimensional vectors, resulting in a two-dimensional matrix. Each element of the resulting matrix is the product of elements from the input vectors. Parameters: - x1 (M,) array_like: First input vector with numeric data type. - x2 (N,) array_like: Second input vector with numeric data type. Returns: - out (M, N) array: The outer product matrix, with elements defined by multiplying each element of the first vector by each element of the second vector."
  },
  "numpy.linalg.slogdet": {
    "new_func": "sign_log_determinant",
    "description": "Determine both the sign and the natural logarithm of the determinant of an array, which can be more stable than computing the determinant directly, particularly for arrays with very small or very large determinants. Parameters: - a (\u2026, M, M) array_like: An input square two-dimensional array, or a stack of them. Returns: - A namedtuple with attributes: - sign (\u2026) array_like: A value representing the sign of the determinant, either 1, 0, or -1 for real matrices, or a complex number of absolute value 1 for complex matrices. - logabsdet (\u2026) array_like: The natural logarithm of the absolute value of the determinant. The determinant itself can be recovered by exponentiating logabsdet and multiplying by the sign."
  },
  "numpy.linalg.svd": {
    "new_func": "singular_value_decomposition",
    "description": "Decompose a matrix into its singular values and corresponding unitary matrices. When applied to a two-dimensional matrix, it results in its factorization into orthogonal matrices and a diagonal matrix of singular values. For higher-dimensional inputs, it performs the operation in a stacked manner, iterating over the first a.ndim - 2 dimensions. Parameters: - a (\u2026, M, N) array_like: A real or complex array with at least two dimensions. - full_matrices bool, optional: If true, shapes of returned unitary matrices are (..., M, M) and (..., N, N). If false, shapes are (..., M, K) and (..., K, N), where K is the minimum of M and N. Default is true. - compute_uv bool, optional: If true, both unitary matrices are computed. Default is true. - hermitian bool, optional: If true, the input matrix is assumed to be Hermitian, which can optimize computation. Default is false. Added in version 1.17.0. Returns: - U array: Left singular vectors, only returned if compute_uv is true. - S array: Singular values, sorted in descending order. - Vh array: Right singular vectors (Hermitian transpose), only returned if compute_uv is true."
  },
  "numpy.linalg.solve": {
    "new_func": "matrix_equation_resolver",
    "description": "Resolves a linear matrix equation or a group of linear equations. It computes the precise outcome of the equation where the matrix is of full rank. Parameters: - coefficient_matrix (..., M, M) array_like: The leading factor matrix. - dependent_values {(M,), (..., M, K)}, array_like: The outcome or dependent variable values. Returns: - solution_array {(..., M,), (..., M, K)} array: Resolution to the matrix equation. The returned shape is contingent on the dimension of dependent_values. Raises: - LinAlgError: If the coefficient_matrix is singular or non-square."
  },
  "numpy.linalg.svdvals": {
    "new_func": "singular_spectrum",
    "description": "Calculates the singular spectrum of a matrix or a collection of matrices. For each matrix in the collection, the spectrum is determined. Parameters: - matrix (..., M, N) array_like: Input array of shape (..., M, N) with the last two dimensions forming matrices for decomposition. Should be floating-point type. Returns: - spectrum_values array: An array of the singular spectrum vectors of length K, where K = min(M, N)."
  },
  "numpy.linalg.tensordot": {
    "new_func": "multidimensional_inner_product",
    "description": "Computes the inner product of two tensors over specified axes. It sums the element-wise products over the chosen axes. Parameters: - tensor1, tensor2 array_like: Input tensors. - axes int or (2,) array_like: If an integer, it specifies the last axes of tensor1 and the first axes of tensor2 to sum over. If an array, it contains two sequences specifying the axes to sum over for each tensor. Returns: - result_tensor array: The computed inner product of the two input tensors."
  },
  "numpy.linalg.tensorsolve": {
    "new_func": "multi_index_equation_solver",
    "description": "Solves the equation where the tensor is the coefficient and all indices of the unknown tensor are summed over. Parameters: - coefficient_tensor array_like: Coefficient tensor, with its shape being the dependent tensor's shape plus additional dimensions. - dependent_tensor array_like: The right-hand tensor with any shape. - reorder_axes tuple of ints, optional: Axes in the coefficient tensor to reorder to the right before solving. Returns: - solution_tensor array: The tensor that solves the equation, shaped according to the coefficient tensor's additional dimensions. Raises: - LinAlgError: If the coefficient tensor is singular or 'non-square'."
  },
  "numpy.linalg.tensorinv": {
    "new_func": "multidimensional_array_reciprocal",
    "description": "Computes the reciprocal or 'inverse' of an N-dimensional array with respect to the inner product operation. Parameters: - input_tensor array_like: The array to invert, which must have a 'square' shape, meaning the product of the dimensions up to a certain index should equal the product of the remaining dimensions. - index_dim int, optional: The count of initial indices involved in the sum for the reciprocal. Returns: - reciprocal_tensor array: The reciprocal of the input tensor for the inner product operation, with a reshaped dimension order. Raises: - LinAlgError: If the input tensor is singular or 'non-square'."
  },
  "numpy.linalg.trace": {
    "new_func": "diagonal_sum",
    "description": "Calculate the aggregate of values along the diagonal or a specified off-diagonal of one or more square arrays. Parameters: - array (array_like): The input array with shape (..., M, N). - diagonal_offset (int, optional): The position of the diagonal to consider relative to the main diagonal (default is 0). - return_dtype (dtype, optional): The desired data type for the returned array. Returns: - diagonal_aggregate (array): An array with the sum of the diagonal elements, adjusted for any offset, with shape determined by dropping the last two dimensions of the input array and appending the aggregate as the last dimension."
  },
  "numpy.linalg.vecdot": {
    "new_func": "vector_inner_product",
    "description": "Calculate the inner product of two vectors, which may be part of multi-dimensional arrays. Parameters: - vector1 (array_like): First input vector array. - vector2 (array_like): Second input vector array. - along_axis (int, optional): Axis over which to calculate the inner product (default is -1). Returns: - inner_product (array): The inner product of the input vectors along the specified axis."
  },
  "numpy.linalg.vector_norm": {
    "new_func": "magnitude",
    "description": "Calculate the magnitude of a vector or vectors, potentially within a multi-dimensional array, using various norms. Parameters: - vector (array_like): Input array representing the vector(s). - norm_axis ({None, int, 2-tuple of ints}, optional): Axis or axes along which to compute the norms. If None, compute over the entire array (default is None). - preserve_dimensions (bool, optional): If true, the reduced dimensions are retained with size one (default is False). - norm_order ({1, -1, 2, -2, inf, -inf, 'fro', 'nuc'}, optional): The order of the norm to apply. Returns: - vector_magnitude (array): The computed magnitude(s) of the input vector(s)."
  },
  "numpy.linalg.qr": {
    "new_func": "orthogonal_triangular_decomp",
    "description": "Perform orthogonal-triangular decomposition on a matrix or a stack of matrices. Parameters: - matrix (array_like): Input array with dimensions at least 2. - decomp_mode ({'reduced', 'complete', 'r', 'raw'}, optional): Determines the shape of the returned arrays (default is 'reduced'). Returns: - decomposition (namedtuple or arrays): Depending on 'decomp_mode', returns a namedtuple with Q and R matrices or the arrays (h, tau) representing the Householder reflectors and their scaling factors respectively. Raises: - LinAlgError: If decomposition fails."
  },
  "numpy.lib.NumpyVersion": {
    "new_func": "version_parser",
    "description": "Parses version strings and allows for their comparison, specifically designed to handle version strings with various pre-release and development suffixes. Parameters: - version_str (str): Version string adhering to the versioning format. Returns: - comparison_result: An object that can be compared against other version strings or instances of the same class. Raises: - ValueError: If the input is not a valid version string."
  },
  "numpy.lib.Arrayterator": {
    "new_func": "BufferedSliceIterator",
    "description": "This class provides an iterator that enables reading large arrays in smaller, contiguous blocks, facilitating iteration over array-like objects without loading the entire data into memory. It supports slicing and is compatible with various storage formats, including on-disk binary files. Parameters: - var (array_like): The array or array-like object to iterate over. - buf_size (int, optional): The buffer size determining the maximum number of elements to read into memory at once. Defaults to reading as many elements as possible. Attributes: - shape (tuple of int): The dimensions of the array being iterated. - flat (iterator): A one-dimensional iterator for the object."
  },
  "numpy.lib.add_docstring": {
    "new_func": "AppendDocumentation",
    "description": "This function attaches additional documentation to a built-in object if it is possible. It raises an error if the object already has documentation or if the object type is not supported for this operation."
  },
  "numpy.lib.add_newdoc": {
    "new_func": "EnhanceDocumentation",
    "description": "This procedure enables the addition of explanatory text to an existing object, predominantly for those defined at the C level. Intended mainly for internal enhancements, it allows docstring updates without recompilation. Parameters: - place (str): The full name of the module from where to import. - obj (str or None): The identifier of the object to document. - doc (str or list of tuples): The text or list of (attribute, text) pairs to be used as the new documentation. - warn_on_python (bool, optional): If set to True, warns when attaching a docstring to a pure Python object. Note: Failure to write a docstring does not raise an error, but if the object doesn't exist, an error will be raised."
  },
  "numpy.lib.array_utils": {
    "new_func": "AssortedArrayTools",
    "description": "This module comprises a variety of utility functions for array manipulation. It includes methods for obtaining the memory bounds of an array, normalizing axis indices within an array's dimensions, and converting axis arguments into tuples of axis indices."
  },
  "numpy.lib.format": {
    "new_func": "BinaryArraySerialization",
    "description": "This module defines a binary file format for the storage and retrieval of arbitrary arrays with full metadata. It supports both single-array (.npy) and multi-array (.npz) files, enabling the preservation of array shape, data type, and order information across different systems. Features include support for nested record and object arrays, compatibility with both little-endian and big-endian data, and the ability to memory-map files for efficient access. Limitations include loss of subclass attributes and potential changes in field names for structured dtypes with empty names. Functions within this module facilitate conversion between array descriptors and data types, header metadata retrieval, and both reading from and writing to disk."
  },
  "numpy.lib.mixins": {
    "new_func": "array_operator_mixins",
    "description": "Provides mixin classes for user-defined array types to enable arithmetic and operator special methods without direct inheritance from the primary array class. These mixin classes use the '__array_ufunc__' protocol to define the behavior of all operators. Classes: - OperatorsMixin: A class that defines all operator special methods using the unified function protocol."
  },
  "numpy.lib.introspect": {
    "new_func": "cpu_feature_inspector",
    "description": "Provides helper functions for examining the internal aspects of optimized functions. Functions: - optimal_function_capabilities([optional_function_name, optional_signature]): Returns a mapping containing the information about the CPU features utilized by optimized functions."
  },
  "numpy.lib.npyio": {
    "new_func": "datafile_interaction",
    "description": "Facilitates input and output operations related to data files. Classes: - GenericDataSource([optional_destination_path]): Manages access to various types of data sources, such as local files or remote locations (HTTP, FTP, etc.). - ZipArchiveLazyLoader(file_identifier): Behaves like a dictionary, allowing lazy loading of files from a provided zip archive upon construction."
  },
  "numpy.lib.scimath": {
    "new_func": "enhanced_math_routines",
    "description": "Provides wrapper functions for mathematical operations, ensuring correct output data-types across complex domains. These functions handle edge cases, such as branch cuts and complex plane calculations, more gracefully than their standard counterparts. Examples include calculating square roots, logarithms across different bases, power functions, and inverse trigonometric functions, providing mathematically valid results even for complex inputs. Functions: - square_root(input_value): Calculates the square root. - natural_log(input_value): Calculates the natural logarithm. - binary_log(input_value): Calculates the base 2 logarithm. - base_n_log(base_value, input_value): Calculates the logarithm to the specified base. - decimal_log(input_value): Calculates the base 10 logarithm. - exponentiate(base_value, exponent_value): Raises the base to the given exponent. - inverse_cosine(input_value): Calculates the arc cosine. - inverse_sine(input_value): Calculates the arc sine. - inverse_hyperbolic_tangent(input_value): Calculates the inverse hyperbolic tangent."
  },
  "numpy.lib.stride_tricks": {
    "new_func": "stride_manipulation",
    "description": "Provides utility functions to manipulate array strides for achieving specific effects, as detailed in the array documentation. Functions: - custom_strided_view(input_array[, desired_shape, new_strides, subok, writeable]): Creates a new view into the array with a specified shape and stride pattern. - moving_window_view(input_array, window_dimensions[, axis, ...]): Generates a view of the array with a sliding window of the given shape over the specified dimensions."
  },
  "numpy.testing.assert_": {
    "new_func": "verification_pass",
    "description": "Validates a condition even in optimized execution modes. Accepts a callable message to provide detailed evaluation upon failure. Unlike the standard Python assert, this remains operational with the -O optimization flag. Refer to Python's own documentation for usage instructions."
  },
  "numpy.testing.assert_allclose": {
    "new_func": "validate_approximate_equality",
    "description": "Checks if two objects agree within a specified tolerance. Verifies that the shape and elements of both objects are equivalent, with an exception for NaNs, which are compared as equivalent if both objects contain them in the same positions. The comparison of actual versus desired values is subject to the combined relative and absolute tolerances, rtol and atol. Arguments include actual (array_like), desired (array_like), rtol (float), atol (float), equal_nan (bool), err_msg (string), verbose (bool), and strict (bool). An AssertionError is raised upon discrepancy in shapes, data types (when strict is True), or element values beyond the permitted tolerance."
  },
  "numpy.testing.assert_almost_equal": {
    "new_func": "check_near_identity",
    "description": "Ensures two items are nearly identical to a specified precision level. The discrepancy between the actual and desired values is tested against a threshold defined by the decimal argument. This function is suitable for comparing single values or arrays, and exceptions are raised for any values that differ more than the allowable margin. Inputs include actual (array_like), desired (array_like), decimal (int), err_msg (string), and verbose (bool). An AssertionError is thrown if the precision criterion is not met."
  },
  "numpy.testing.assert_approx_equal": {
    "new_func": "confirm_significant_agreement",
    "description": "Affirms that two numerical values are approximately equivalent, considering a certain number of significant digits. The function compares the actual and desired values against a defined precision level indicated by the significant parameter. This approximation check raises an AssertionError for any actual and desired pair that do not match up to the specified number of significant figures. Inputs are actual (scalar), desired (scalar), significant (int), err_msg (string), and verbose (bool)."
  },
  "numpy.testing.assert_array_almost_equal": {
    "new_func": "assert_near_congruence",
    "description": "Determines whether two arrays are nearly congruent within a given precision. Assesses both shape conformity and element-wise closeness, which is determined by a specified decimal threshold. Similar to element-wise comparisons, NaNs are regarded as equivalent if they occupy corresponding locations in both arrays. The function requires actual (array_like), desired (array_like), decimal (int), err_msg (string), and verbose (bool) as inputs. An AssertionError is issued for shape mismatches or when element divergence exceeds the permitted threshold."
  },
  "numpy.testing.assert_array_almost_equal_nulp": {
    "new_func": "relative_tolerance_comparison",
    "description": "This function compares two arrays element-wise, checking whether they are within a specified number of units in the last place (ULP). It is particularly useful for comparison of floating-point values that may have variable precision.\nParameters:\n- x, y (array_like): Input arrays to compare.\n- nulp (int, optional): The maximum allowed difference expressed in ULPs. Defaults to 1.\nReturns:\n- None\nRaises:\n- AssertionError: If the difference between any elements in the arrays exceeds the specified tolerance."
  },
  "numpy.testing.assert_array_equal": {
    "new_func": "elementwise_equality_verification",
    "description": "This function asserts that two given array-like objects have the same shape and all their corresponding elements are equal. It handles NaNs as normal numbers, allowing comparison of arrays with NaNs in the same location.\nParameters:\n- actual (array_like): The actual object to check.\n- desired (array_like): The expected object.\n- err_msg (str, optional): Custom error message on test failure.\n- verbose (bool, optional): If true, provides a detailed error message.\n- strict (bool, optional): If true, enforces strict shape and dtype matching. Defaults to False.\nRaises:\n- AssertionError: If the objects are not equal."
  },
  "numpy.testing.assert_array_less": {
    "new_func": "elementwise_inequality_assertion",
    "description": "This function asserts that all elements in the first array-like object are strictly less than those in the second array-like object. It checks for shape equality and the correct order of elements.\nParameters:\n- x (array_like): The array to compare as the smaller one.\n- y (array_like): The array to compare as the larger one.\n- err_msg (string, optional): Message to raise if the assertion fails.\n- verbose (bool, optional): If true, include the conflicting values in the error message.\n- strict (bool, optional): If true, enforce strict shape and dtype matching.\nRaises:\n- AssertionError: If elements in x are not strictly less than those in y."
  },
  "numpy.testing.assert_array_max_ulp": {
    "new_func": "maximum_deviation_in_ulp",
    "description": "This function checks that all corresponding elements of two arrays differ by at most a specified number of units in the last place (ULP). It is used to compare floating-point arrays for near equality.\nParameters:\n- a, b (array_like): Arrays to compare.\n- maxulp (int, optional): The maximum allowed ULP difference. Defaults to 1.\n- dtype (dtype, optional): Data-type to coerce the arrays to if provided. Defaults to None.\nReturns:\n- ret (array): Array of ULP differences between elements in a and b.\nRaises:\n- AssertionError: If any elements differ by more than maxulp."
  },
  "numpy.testing.assert_equal": {
    "new_func": "absolute_equality_assessment",
    "description": "This function asserts the complete equality of two objects which may be scalars, lists, tuples, dictionaries, or arrays. It checks all elements for exact equality, raising an exception at the first discrepancy.\nParameters:\n- actual (array_like): The object under test.\n- desired (array_like): The expected object for comparison.\n- err_msg (str, optional): Message to raise if the test fails.\n- verbose (bool, optional): If true, provide detailed error messages.\n- strict (bool, optional): If true, enforce strict shape and dtype matching for arrays.\nRaises:\n- AssertionError: If the objects are not equal in all aspects."
  },
  "numpy.testing.clear_and_catch_warnings": {
    "new_func": "reset_and_monitor_alerts",
    "description": "Reset the warning registry and manage alert capturing within a block of code. This context manager is designed to capture alerts in specified modules and reset their registry to allow repeated trigger of similar alerts within the block. It can be used to ensure that alerts are not missed in a test suite due to Python's internal caching in the __warningregistry__ of a module.\n\nParameters:\n- record (bool, optional): Whether to capture alerts and append to a list which is returned by the manager. Defaults to False, returning None.\n- modules (sequence, optional): Modules to reset alert registry for. All 'ignore' filters should be for these modules.\n\nReturns:\n- list or None: A list of captured alert arguments if record is True; otherwise, None."
  },
  "numpy.testing.decorate_methods": {
    "new_func": "adorn_methods_with_pattern",
    "description": "Apply a specified decorator to public methods of a given class that match a particular regular expression pattern. Private methods starting with an underscore are excluded from decoration.\n\nParameters:\n- cls (class): The class whose methods will be modified.\n- decorator (callable): The decorator to be applied to matched methods.\n- testmatch (compiled regexp or str, optional): Pattern to match method names against. Defaults to the nose default or a compiled version of a provided string pattern."
  },
  "numpy.testing.measure": {
    "new_func": "benchmark_execution",
    "description": "Determine the time taken to execute a provided code segment, which is intended to be run in the caller's scope. The code string is compiled and executed multiple times for increased accuracy of the time measurement.\n\nParameters:\n- code_str (str): The code segment to execute.\n- times (int, optional): How many times to run the code. Defaults to 1.\n- label (str, optional): A label for identifying the code segment. Used in error messages during runtime.\n\nReturns:\n- elapsed (float): The total time in seconds for the code execution."
  },
  "numpy.testing.assert_no_warnings": {
    "new_func": "verify_silence",
    "description": "Ensure that a specified callable, when executed, does not emit any alerts. This can also be used as a context manager to wrap a block of code that should not produce any alerts. It fails the test if any alerts are raised.\n\nParameters:\n- func (callable): The function to call and evaluate for alerts.\n- *args: Positional arguments passed to the function.\n- **kwargs: Keyword arguments passed to the function.\n\nReturns:\n- The result of the callable."
  },
  "numpy.testing.print_assert_equal": {
    "new_func": "display_equality_verification",
    "description": "Check if two objects are equivalent and present a message if they are not. A direct comparison is made between the actual and the expected objects. If they differ, an error message detailing the discrepancy is printed.\n\nParameters:\n- test_string (str): A message included in the error output.\n- actual (object): The object to be compared against the expected result.\n- desired (object): The anticipated outcome of the test.\n\nExamples are provided to demonstrate usage and output upon both passing and failing the equality test."
  },
  "numpy.testing.rundocs": {
    "new_func": "execute_document_tests",
    "description": "Execute the examples embedded in the documentation of a specific file. If any of the tests fail, an error is raised according to the specified behavior. Parameters: - filepath: str, The path to the file containing the testable examples. - enforce_error: bool, Flag to determine whether to raise an error upon test failure. Default is True. Returns: None, but outputs the results of the test execution directly."
  },
  "numpy.testing.suppress_warnings": {
    "new_func": "mute_alerts",
    "description": "Provides a mechanism for controlling the display of warnings during runtime. It acts similar to the standard library's warnings control but with enhancements for managing the visibility of repetitive warnings, especially in situations where warnings may not reliably reappear. Parameters: - filter_policy: str, optional, Determines how often unsuppressed warnings are forwarded. Acceptable values include 'always', 'once', 'module', or 'location'. Default is 'always'. Returns: A context manager that can also be used as a decorator to suppress specified warnings within a block of code or a function."
  },
  "numpy.strings.capitalize": {
    "new_func": "initial_uppercase",
    "description": "Transforms an array of string-like elements, making the first character uppercase and the rest lowercase for each element. This operation is sensitive to the current locale for byte strings. Parameters: - input_array: array-like, The array of strings to be modified. Returns: - modified_array: array, An array with the same type as the input, where each string has its first character capitalized."
  },
  "numpy.strings.add": {
    "new_func": "concatenate_elements",
    "description": "Performs an element-wise concatenation of two input arrays. The operation is compatible with broadcasting rules. Parameters: - element1, element2: array_like, The arrays to be combined. - output: array, optional, A location to store the result. - condition: array_like, optional, A boolean array that specifies where the operation should take place. - **kwargs: Additional arguments including casting type, order, etc. Returns: - concatenated: array or scalar, The result of the element-wise addition. If both inputs are scalars, the result is a scalar."
  },
  "numpy.strings.center": {
    "new_func": "middle_align_text",
    "description": "Adjusts elements in an array to be center-aligned within strings of a specified width. If the specified width is less than the length of the element, the original string is returned. Parameters: - input_array: array-like, The array of strings to be centered. - field_width: array_like, The desired width of each element in the output array. - padding_character: array-like, optional, The character used for padding if the string is shorter than 'field_width'. Default is a space character. Returns: - centered_array: array, An array of the same type as the input, with each element center-aligned and padded as specified."
  },
  "numpy.strings.count": {
    "new_func": "substring_tally",
    "description": "This operation tallies the number of times a specified sequence appears within each element of an array, searching within a specified range. Parameters: - target: Array-like with string-like elements. - sequence: Array-like with string-like elements to search for. - begin: Array-like with any integer type, indicating the start of the search range. - finish: Array-like with any integer type, indicating the end of the search range. Returns: - tally: An array of integers representing the count of non-overlapping occurrences of the sequence within the target's elements."
  },
  "numpy.strings.decode": {
    "new_func": "bytes_to_text",
    "description": "This function converts each element of a byte array into a string using the specified character encoding. Parameters: - byte_array: Array-like with byte elements. - charset: Optional string indicating the character encoding used for conversion. - error_handling: Optional string specifying the strategy for handling encoding errors. Returns: - decoded_array: An array of decoded strings."
  },
  "numpy.strings.encode": {
    "new_func": "text_to_bytes",
    "description": "Performs an element-wise encoding of string elements into bytes using the specified charset. Parameters: - string_array: Array-like with string elements. - charset: Optional string indicating the encoding to use. - error_handling: Optional string specifying how to manage errors in encoding. Returns: - encoded_array: An array where each string element has been encoded into bytes."
  },
  "numpy.strings.endswith": {
    "new_func": "suffix_checker",
    "description": "Determines element-wise if the elements in an array terminate with the specified suffix. Parameters: - main_array: Array-like with string-like elements. - tail: Array-like with string-like elements representing the suffix to check. - begin: Array-like with any integer type, indicating the starting position for the check. - finish: Array-like with any integer type, indicating the ending position for the check. Returns: - matches: An array of boolean values, each indicating whether the corresponding element in the main array ends with the given suffix."
  },
  "numpy.strings.equal": {
    "new_func": "element_comparator",
    "description": "Compares two arrays element-wise for equality. Parameters: - array1, array2: Array-like inputs to be compared. These must be broadcastable to a common shape. - result_container: Optional location to store the result. - condition: Optional array-like condition to broadcast over the input, determining where the comparison is applied. - additional_params: Optional arguments for advanced usage. Returns: - comparison_result: An array or scalar indicating the element-wise equality of array1 and array2, often of boolean type unless a specific object type is requested."
  },
  "numpy.strings.find": {
    "new_func": "locate_substring",
    "description": "Identify the initial occurrence index of a specified sequence within each element of the input array, searching within a defined range. The search range is specified by the 'start' and 'end' positions, using slice notation. If the sequence is not present within the specified range, the result is -1 for that element.\nParameters:\na: Input array of string type elements.\nsub: The sequence to locate within each element.\nstart: The beginning index to start searching from within the string. Defaults to 0.\nend: The ending index to stop searching within the string. If not specified, the search goes to the end of the string.\nReturns:\ny: An array of integer indices indicating the first occurrence of the sequence within each element, or -1 if not found."
  },
  "numpy.strings.greater": {
    "new_func": "alphabetic_supremacy",
    "description": "Evaluate the lexicographical superiority of corresponding elements in two input arrays on an element-wise basis, resulting in a boolean outcome.\nParameters:\nx1: First input array for comparison.\nx2: Second input array to compare against.\nout: Alternate output array to store the results. Must be broadcastable to the shape resulting from input arrays.\nwhere: Conditional mask specifying where to apply the operation.\n**kwargs: Additional arguments affecting behavior and return type of the operation.\nReturns:\noutput: Array indicating the result of comparison; elements where x1 lexicographically precedes x2 are marked as True, others as False."
  },
  "numpy.strings.greater_equal": {
    "new_func": "alphabetic_noninferiority",
    "description": "Determine if elements in one array are lexicographically greater than or equal to those in another array, evaluated on an element-wise basis. The comparison results in a boolean value for each element pair.\nParameters:\nx1: First array of strings for comparison.\nx2: Second array of strings to compare with.\nout: An array to store the boolean result of the comparison; shape must be broadcast-compatible.\nwhere: Condition array to decide where the comparison should be applied; follows broadcasting rules.\n**kwargs: Additional parameters controlling the behavior of the operation.\nReturns:\nresult: A boolean array where True indicates x1 is greater than or equal to x2 lexicographically."
  },
  "numpy.strings.index": {
    "new_func": "locate_substring_strict",
    "description": "Find the index of a specified substring within each string element of the input array, adhering strictly to the defined start and end range. Unlike a similar function, this one raises an error if the substring is not found.\nParameters:\na: Array of string type elements to search within.\nsub: The substring to find within each element.\nstart: The index to start the search from within the string.\nend: The index to end the search within the string.\nReturns:\nindices: Array of indices where the substring is found within the specified range in each element."
  },
  "numpy.strings.isalnum": {
    "new_func": "check_alphanumeric",
    "description": "Assess each string in the array to verify whether all characters are alphanumeric (comprising letters and numbers) and that there is at least one character in the string.\nParameters:\nx: Array of string elements to evaluate.\nout: Optional array to store the boolean results.\nwhere: Optional condition array that specifies which elements to evaluate.\n**kwargs: Additional parameters for fine-tuning the operation.\nReturns:\nassessment: An array of boolean values indicating whether each element is purely alphanumeric."
  },
  "numpy.strings.isdecimal": {
    "new_func": "numeric_characters_only",
    "description": "Assesses each element for the exclusive presence of characters used in the formation of base-10 numbers. It evaluates an array-like object, returning a boolean array indicating whether each element consists solely of these numeric symbols. Parameters: - x (array_like): Input array with elements of string-like data type. - out (array, optional): Alternative output array to store the result. - where (array_like, optional): Condition array to determine which elements to assess. Returns: - result (array): Array of booleans corresponding to the assessment outcome."
  },
  "numpy.strings.isalpha": {
    "new_func": "alphabetic_characters_check",
    "description": "Determines if each element of the input contains only letters. It examines an array-like input for alphabetic characters and returns a boolean array indicating whether each element is composed exclusively of them. Parameters: - x (array_like): Input array with string-like data type elements. - out (array, optional): Alternate array to store the outcome. - where (array_like, optional): Condition array to specify which elements to evaluate. Returns: - result (array): A boolean array representing the evaluation for each element."
  },
  "numpy.strings.isdigit": {
    "new_func": "digit_characters_inspection",
    "description": "Inspects each element for the sole presence of digit characters. It analyzes an array-like structure to ascertain if each element contains only digits and yields a boolean array reflecting this. Parameters: - x (array_like): Input array with elements in string-like formats. - out (array, optional): Output array for storing results. - where (array_like, optional): Conditions to apply to elements when determining the result. Returns: - result (array): Boolean array indicating the presence of only digit characters in each element."
  },
  "numpy.strings.isnumeric": {
    "new_func": "numeric_value_characters_assessment",
    "description": "Evaluates each element to confirm the presence of only numeric value characters. This function scrutinizes an array-like input and produces a boolean array, identifying whether each element is comprised solely of characters with numeric value properties. Parameters: - x (array_like): Array-like input with string-like data type elements. - out (array, optional): Designated array for result storage. - where (array_like, optional): Conditional array to select elements for evaluation. Returns: - result (array): Boolean array signaling whether each element contains only numeric value characters."
  },
  "numpy.strings.islower": {
    "new_func": "lowercase_cased_characters_verification",
    "description": "Verifies that each element consists of lowercase cased characters only. This function processes an array-like input of strings and returns a boolean array, indicating whether each element is exclusively composed of lowercase cased characters. Parameters: - x (array_like): Input array with elements of string-like data type. - out (array, optional): Alternative destination array for storing the result. - where (array_like, optional): Condition array to apply checks selectively. Returns: - result (array): Array of booleans with each element's verification result."
  },
  "numpy.strings.isspace": {
    "new_func": "blank_scan",
    "description": "Examines each element to check if all characters are blank spaces and confirms the presence of at least one character. It operates on an array-like input with string data types. The function returns a boolean array indicating the presence of only blank space characters in each element of the input array. Parameters: - input_array: Array-like with string data types. - output_array: Optional. If provided, the result is stored here; must be broadcastable to input shape. - condition: Optional. A conditional array that is broadcast over the input. The function is applied where the condition is True. Returns: - result: An array of boolean values indicating whether each element contains only whitespace characters."
  },
  "numpy.strings.istitle": {
    "new_func": "capitalized_check",
    "description": "Determines whether each element of the input array is title-cased, meaning it starts with an uppercase letter followed by lowercase letters, and there is at least one character. The function takes an array-like input with string data types and returns a boolean array. Parameters: - input_array: Array-like with string data types. - output_array: Optional. A location to store the result; must be broadcastable to input shape. - condition: Optional. A boolean array that is broadcast over the input. The function is applied where the condition is True. Returns: - result: An array of boolean values indicating whether each element is title-cased."
  },
  "numpy.strings.less": {
    "new_func": "elementwise_compare",
    "description": "Evaluates the truth value of whether elements in one array are less than those in another, on an element-wise basis. Both arrays should be broadcastable to a common shape. The result is typically a boolean array indicating the comparison result. Parameters: - first_input: First input array for comparison. - second_input: Second input array for comparison. - output_array: Optional. A location to store the comparison result; must be broadcastable to the input shapes. - condition: Optional. A boolean array that is broadcast over the inputs. The comparison is applied where the condition is True. Returns: - comparison_result: An array or scalar representing the comparison of input arrays, typically of boolean type."
  },
  "numpy.strings.isupper": {
    "new_func": "uppercase_verifier",
    "description": "Checks if all cased characters in each element of the input array are in uppercase. The function returns a boolean array indicating whether each element has only uppercase characters. Parameters: - input_array: Array-like with string data types. - output_array: Optional. If provided, the result is stored here; must be broadcastable to input shape. - condition: Optional. A conditional array that is broadcast over the input. The function is applied where the condition is True. Returns: - result: An array of boolean values indicating whether each element contains only uppercase characters."
  },
  "numpy.strings.ljust": {
    "new_func": "left_align_fill",
    "description": "Aligns each element of an input array to the left within a string of specified width, potentially filling the remaining space with a specified character. The function operates on array-like inputs with string data types and returns an array with left-justified strings. Parameters: - input_array: Array-like with string data types. - field_width: Integer representing the length of the resulting strings. - padding_character: Optional character for padding, default is a space. Returns: - justified_array: An array with left-justified elements, padded as necessary."
  },
  "numpy.strings.less_equal": {
    "new_func": "comparator_not_greater",
    "description": "Determines the element-wise relation of two arrays by checking if elements in the first array are not greater than those in the second array. Parameters: - x1, x2 (array_like): Input arrays to compare. They must be broadcastable to a common shape. - out (array, None, or tuple of array and None, optional): A location to store the result. Must have a shape that the inputs broadcast to. If not provided, a new array is returned. - where (array_like, optional): Specifies where to apply the comparison. If True, the comparison is applied; otherwise, the original value is retained. - **kwargs: Additional arguments for advanced usage. Returns: - out (array or scalar): Bool array indicating the result of the comparison, or a scalar if both inputs are scalars."
  },
  "numpy.strings.lower": {
    "new_func": "to_lowercase",
    "description": "Transforms the characters of an input array to their lowercase equivalents. Parameters: - a (array-like): Input array with elements of string types. Returns: - out (array): Array of the same type as 'a', with all characters in lowercase."
  },
  "numpy.strings.lstrip": {
    "new_func": "trim_leading_characters",
    "description": "Creates a copy of the input array with specified leading characters removed from each element. Parameters: - a (array-like): Input array of strings. - chars (scalar, optional): Set of characters to remove. If not specified, defaults to whitespace. Returns: - out (array): Array with leading characters removed from each element."
  },
  "numpy.strings.multiply": {
    "new_func": "replicate_strings",
    "description": "Repeats each element of an array of strings a specified number of times. Parameters: - a (array_like): Input array of strings. - i (array_like): Array of integers specifying the number of repetitions for each string. Returns: - out (array): Array where each string is repeated according to the corresponding number in 'i'."
  },
  "numpy.strings.mod": {
    "new_func": "string_interpolation",
    "description": "Performs old-style string formatting by interpolating values into placeholders in the input strings. Parameters: - a (array_like): Array of string templates with placeholders. - values (array_like): Array of values to interpolate into the templates. Returns: - out (array): Array of strings with interpolated values."
  },
  "numpy.strings.not_equal": {
    "new_func": "mismatch_detector",
    "description": "Compares elements from two arrays on an element-wise basis to determine if they are not the same. Parameters: - x1, x2 (array_like): Arrays to be compared. They must be broadcastable to a common shape. - out (array, optional): A location to store the result. If not provided, a new array is created. - where (array_like, optional): Specifies where to apply the operation. If True, the operation is applied at that location. - **kwargs: Additional arguments for advanced usage. Returns: - result (array or scalar): An array of boolean values indicating whether the elements are different. The output is of type bool unless dtype=object is specified. Scalar output is produced if both inputs are scalars."
  },
  "numpy.strings.rindex": {
    "new_func": "substring_locator_reverse",
    "description": "Searches for a substring within each element of an array, starting from the end, and returns the highest index where the substring is found. Raises a ValueError if the substring is not present. Parameters: - a (array_like): The input array with string elements. - sub (array_like): The substring to search for. - start, end (array-like, optional): The range of indices to search within, similar to slicing. Returns: - indices (array): An array of integer indices indicating the last occurrence of the substring."
  },
  "numpy.strings.replace": {
    "new_func": "substitute_substring",
    "description": "Creates a new array by replacing specified occurrences of a substring within each element of the input array with a new string. Parameters: - a (array_like): Input array with string elements. - old, new (array_like): The old substring to be replaced, and the new substring to replace it with. - count (array_like, optional): The number of times to replace the old substring. If unspecified, all occurrences are replaced. Returns: - modified_array (array): An array containing the elements with the replaced substrings."
  },
  "numpy.strings.rfind": {
    "new_func": "substring_search_reverse",
    "description": "Finds the highest index of a specified substring within each element of the input array, searching from the end towards the beginning. The search is bounded by the specified start and end indices. Parameters: - a (array-like): Input array of strings. - sub (array-like): Substring to search for. - start, end (array-like, optional): Range of indices to search within, following slice notation. Returns: - locations (array): An array of integers representing the highest index where the substring is found."
  },
  "numpy.strings.rjust": {
    "new_func": "align_right",
    "description": "Adjusts each string element within an array to be right-aligned within a specified width. Pads with a specified character if necessary. Parameters: - a (array-like): Array containing string elements. - width (array_like): The width to align the strings to. - fillchar (array-like, optional): Character used for padding, defaults to a space. Returns: - adjusted_array (array): An array with elements right-aligned to the given width."
  },
  "numpy.strings.rstrip": {
    "new_func": "trim_trailing_characters",
    "description": "Produces a replica of each element with specified characters eliminated from the end. Parameters: - items (array-like): Collection of strings or bytes. - trim_set (scalar): Set of characters to remove, if not provided, defaults to whitespace. Returns: - result (array): Array of processed strings or bytes."
  },
  "numpy.strings.startswith": {
    "new_func": "commence_with_prefix",
    "description": "Yields an array of boolean values indicating whether each string element commences with the specified beginning sequence. Parameters: - items (array-like): Collection of strings or bytes. - beginning (array-like): Sequence to check at the start. - from_position (array_like): Starting index. - to_position (array_like): Ending index. Returns: - matches (array): Array of truth values."
  },
  "numpy.strings.str_len": {
    "new_func": "item_length",
    "description": "Calculates the extent of each string element, measured in bytes for byte strings or Unicode code points for Unicode strings. Parameters: - elements (array_like): Collection of strings or bytes. Returns: - lengths (array): Array of integer lengths."
  },
  "numpy.strings.strip": {
    "new_func": "prune_edge_characters",
    "description": "Generates a copy of each string element with specified characters excised from both the beginning and end. Parameters: - items (array-like): Collection of strings or bytes. - trim_set (scalar): Set of characters to remove, defaults to whitespace if not specified. Returns: - cleaned (array): Array of strings or bytes with the characters removed."
  },
  "numpy.strings.title": {
    "new_func": "capitalize_titles",
    "description": "Transforms each string element to have the initial character in uppercase and the rest in lowercase, following the title case convention. Parameters: - items (array-like): Collection of strings or bytes. Returns: - titled_items (array): Array with each element in title case."
  },
  "numpy.strings.swapcase": {
    "new_func": "toggle_casing",
    "description": "Transform each element in the input array by inverting the case of all alphabetic characters. Uppercase characters are turned into lowercase, and lowercase characters become uppercase. This alteration is dependent on the locale for 8-bit strings. Parameters: - a (array-like): Array with elements of string, byte, or string data types. Returns: - out (array): Array with elements having inverted case, preserving their respective data types."
  },
  "numpy.strings.translate": {
    "new_func": "remap_and_prune_characters",
    "description": "Modify each string element in the provided array by deleting specified characters and remapping the rest according to a translation table. This process is performed element-wise. Parameters: - a (array-like): Array with byte or string data types. - table (str): Translation table of length 256 for character mapping. - deletechars (str, optional): Characters to be removed from the strings. Returns: - out (array): Array with modified string elements based on the translation table and deletion of characters."
  },
  "numpy.strings.zfill": {
    "new_func": "prepend_zeros",
    "description": "Generate a new array where numeric strings from the input array are padded with leading zeros to reach a specified width. This operation is applied element-wise. Parameters: - a (array_like): Array with elements of string, byte, or string data types. - width (int): The target width that each element should reach after padding with zeros. Returns: - out (array): Array with elements padded with leading zeros, maintaining their original data types."
  },
  "numpy.strings.upper": {
    "new_func": "capitalize_elements",
    "description": "Convert all alphabetic characters in each element of the input array to their uppercase form. This conversion is conducted for each element individually. For 8-bit strings, the behavior can be influenced by the current locale settings. Parameters: - a (array-like): Array containing string, byte, or string data types. Returns: - out (array): Array with each element transformed to contain only uppercase characters, consistent with the input data types."
  },
  "numpy.arctanh": {
    "new_func": "inverse_tangent_hyperbolicus",
    "description": "Calculate the inverse of the hyperbolic tangent for each element of the input array, element-wise. This operation is defined for real and complex numbers, which fall within the domain of the function.\nParameters:\n- input_array (array_like): Input array containing elements for which the inverse hyperbolic tangent is to be calculated.\n- output (array, None, or tuple of array and None, optional): A destination array where the result is stored. It must be broadcast-compatible with the input_array. If not provided, a new array is allocated.\n- condition (array_like, optional): Boolean array that specifies where the operation should be applied. If True at a location, the output will be set to the calculated value; otherwise, it retains its original value.\n- **kwargs: Additional keyword arguments for more control over the operation.\nReturns:\n- result (array or scalar): An array with the same shape as input_array, containing the inverse hyperbolic tangent values."
  },
  "numpy.argmin": {
    "new_func": "minimum_index_locator",
    "description": "Identify the locations of the smallest values along the specified axis in the input collection. If multiple minimum values exist, the index of the first occurrence is returned.\nParameters:\n- collection (array_like): The array to examine.\n- axis (int, optional): The axis along which to find the minimum indices. If not specified, the array is flattened before operation.\n- output (array, optional): Array to store the result. It should have an appropriate shape and data type.\n- maintain_dims (bool, optional): If True, the reduced axis is retained as a dimension with size one, allowing the result to broadcast correctly against the input array.\nReturns:\n- index_array (array of ints): An array of indices for the minimum values. It has the same shape as the input array with the reduced axis removed, unless maintain_dims is True, which maintains the original shape."
  },
  "numpy.argpartition": {
    "new_func": "partial_sort_indexer",
    "description": "Provides an array of indices that would partially sort the input array such that the element at the provided index (or indices) is in its sorted position, with all elements smaller than it preceding and all larger elements following. The order of elements in the partitions is not guaranteed to be sorted.\nParameters:\n- array_to_partition (array_like): The array to be partially sorted.\n- pivot_indices (int or sequence of ints): The index (or indices) of the element(s) that should be in their final sorted position.\n- axis (int or None, optional): The axis along which to perform the partial sort. If None, the input array is flattened.\n- selection_algorithm (string, optional): The algorithm to be used for the partitioning. Currently, only 'introselect' is supported.\n- field_order (str or list of str, optional): Specifies which fields to compare first when the array has structured fields.\nReturns:\n- index_array (array, int): An array of indices that would partition the input array along the specified axis. Applying this index array to the input array yields a partitioned array."
  },
  "numpy.argsort": {
    "new_func": "index_sorter",
    "description": "Compute the indices that would sort the input array. This function performs an indirect sort along a specified axis and can utilize different sorting algorithms.\nParameters:\n- array_to_sort (array_like): The array for which the sort indices are to be obtained.\n- axis (int or None, optional): The axis to be sorted. If None, the array is flattened before sorting.\n- sort_algorithm (string, optional): The algorithm to be used for sorting, such as 'quicksort', 'mergesort', 'heapsort', or 'stable'.\n- field_sequence (str or list of str, optional): When the array contains fields, this parameter specifies the order in which fields should be compared.\n- is_stable (bool, optional): If set to True, the sort will maintain the relative order of equal elements.\nReturns:\n- sorted_indices (array, int): An array of indices that sort the input array along the specified axis. When applied to the array, it results in a sorted array."
  },
  "numpy.argwhere": {
    "new_func": "nonzero_locator",
    "description": "Determine the locations of non-zero elements in the input dataset. This function groups the indices by element.\nParameters:\n- dataset (array_like): The data to be inspected for non-zero elements.\nReturns:\n- index_array (array): An array of indices corresponding to non-zero elements. The shape of this array is (N, dataset.ndim), where N is the number of non-zero items in the dataset."
  },
  "numpy.choose": {
    "new_func": "select_from_collections",
    "description": "Construct a new array by selecting elements from multiple collections based on an index array. For each position, the output is the element from the collection at the index specified by the index array at that position. Supports different modes for handling out-of-range indices. The shapes of the index and choice arrays are broadcasted to a common shape.\nParameters:\n- index_array (aint array): An array of integers used to select from the collections.\n- collections (sequence of arrays): A sequence of arrays from which to select elements. All arrays must be broadcastable to the same shape.\n- output (out array, optional): An optional array to hold the result. Must have the appropriate shape and dtype.\n- handling_mode ({'raise', 'wrap', 'clip'}, optional): Dictates how out-of-range indices are handled.\nReturns:\n- merged_array (array): The array constructed from the selected elements."
  },
  "numpy.common_type": {
    "new_func": "unify_data_type",
    "description": "Determine a shared data type among the input arrays that can accommodate all values without losing precision. The result is a floating-point scalar type, even if all inputs are of integer types. If any input is an integer array, the minimum precision will be 64-bit float.\nParameters:\n- arrays (arrays): A variable number of input arrays.\nReturns:\n- common_dtype (data type code): The shared data type code."
  },
  "numpy.column_stack": {
    "new_func": "vertical_join",
    "description": "Combine one-dimensional arrays into a two-dimensional array by aligning them as columns. If two-dimensional arrays are provided, they are stacked as-is, similarly to horizontal stacking. One-dimensional arrays are first converted into two-dimensional columns.\nParameters:\n- sequence (sequence of 1-D or 2-D arrays): Arrays to combine. All arrays must have the same length in their first dimension.\nReturns:\n- stacked_array (2-D array): The result of vertically stacking the input arrays."
  },
  "numpy.compress": {
    "new_func": "condense_by_mask",
    "description": "Produce a new array by extracting elements from the input array that correspond to True in the boolean condition array. When working along a specified axis, returns a slice for each index where the condition is True.\nParameters:\n- condition (1-D array of bools): Boolean array indicating which elements to include from the input array.\n- source_array (array_like): Input array from which to extract elements.\n- axis (int, optional): Axis along which to extract slices. If None, the operation is performed on the flattened array.\n- target_array (array, optional): Optional output array to hold the result, must be of the correct shape and type.\nReturns:\n- condensed_array (array): Array containing the extracted elements."
  },
  "numpy.clip": {
    "new_func": "bound_values",
    "description": "Constrain the values in the input array to lie within a given interval. Values below the lower bound are set to the lower bound, and values above the upper bound are set to the upper bound. Optionally performs the operation in-place.\nParameters:\n- source_array (array_like): Array with elements to constrain.\n- lower_bound (array_like or None): Minimum allowable value. If None, no lower clipping is performed.\n- upper_bound (array_like or None): Maximum allowable value. If None, no upper clipping is performed.\n- target_array (array, optional): The array in which to place the result. May be the same as the source_array for in-place operation.\nReturns:\n- constrained_array (array): Array with values limited to the specified range."
  },
  "numpy.concat": {
    "new_func": "array_fusion",
    "description": "Merge a sequence of arrays along a specified axis without changing their data.\nParameters:\n- a1, a2, ... : sequence of array_like, The arrays must have the same shape except in the dimension specified by 'axis'.\n- axis : int, optional, The dimension along which the merge happens. If None, arrays are flattened before merging. Defaults to 0.\n- out : array, optional, A location into which the merged data is placed. Must have the correct shape.\n- dtype : str or dtype, optional, Specifies the data type of the resulting array. Cannot be used with 'out'.\n- casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional, Dictates how data type casting is handled.\nReturns:\n- res : array, The merged array with elements from the input arrays."
  },
  "numpy.concatenate": {
    "new_func": "array_merger",
    "description": "Combine a sequence of arrays along a chosen axis while ensuring uniformity in shape.\nParameters:\n- a1, a2, ... : sequence of array_like, The arrays with identical shape, except for the specified 'axis'.\n- axis : int, optional, The dimension to join the arrays on. Defaults to 0, and if None, arrays are flattened.\n- out : array, optional, The array to store the combined result.\n- dtype : str or dtype, optional, Desired data type for the merged array. Can't be set if 'out' is used.\n- casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional, Specifies the rules for data casting.\nReturns:\n- res : array, The result of joining the input arrays along the specified axis."
  },
  "numpy.conjugate": {
    "new_func": "complex_mirror",
    "description": "Obtain the complex conjugate for each element in the input array, which involves reversing the sign of the imaginary part.\nParameters:\n- x : array_like, Input array containing complex elements.\n- out : array, None, or tuple of array and None, optional, A location to store the output.\n- where : array_like, optional, A condition which is broadcast over the input to determine the output.\n- **kwargs : For additional keyword-only arguments.\nReturns:\n- y : array, The element-wise complex conjugate of the input array."
  },
  "numpy.convolve": {
    "new_func": "sequence_combiner",
    "description": "Carry out the discrete, linear combination of two one-dimensional data sets.\nParameters:\n- a : (N,) array_like, The first one-dimensional sequence for the operation.\n- v : (M,) array_like, The second one-dimensional sequence for the operation.\n- mode : {'full', 'valid', 'same'}, optional, Specifies the mode of convolution.\nReturns:\n- out : array, The linear combination of 'a' and 'v' as a one-dimensional array."
  },
  "numpy.invert": {
    "new_func": "bitwise_complement",
    "description": "Perform a bitwise NOT operation on the elements of an array.\nParameters:\n- x (array_like): An array of integer or boolean data types.\n- out (array, None, or tuple of array and None, optional): A location to store the result. If provided, must have a shape the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple must have a length equal to the number of outputs.\n- where (array_like, optional): A condition that decides whether the result is stored in the output array; the operation is only performed at locations where this condition is True.\n- **kwargs: Additional keyword arguments for advanced use cases.\nReturns:\n- out (array or scalar): The result of the bitwise NOT operation, which is of the same shape as 'x'."
  },
  "numpy.is_busday": {
    "new_func": "valid_weekdays",
    "description": "Identify weekdays that are considered to be valid business days.\nParameters:\n- dates (array_like of datetime64[D]): Dates to evaluate.\n- weekmask (str or array_like of bool, optional): A sequence indicating valid business days, with Monday as the first day.\n- holidays (array_like of datetime64[D], optional): Dates to be recognized as holidays.\n- busdaycal (busdaycalendar, optional): An object specifying a custom set of valid days.\n- out (array of bool, optional): An array to be filled with the results.\nReturns:\n- out (array of bool): An array of the same shape as 'dates', with True for each valid business day and False for invalid ones."
  },
  "numpy.isclose": {
    "new_func": "approx_equality",
    "description": "Evaluate the approximate equality of two arrays within a certain tolerance.\nParameters:\n- a, b (array_like): Input arrays for comparison.\n- rtol (array_like): Relative tolerance parameter.\n- atol (array_like): Absolute tolerance parameter.\n- equal_nan (bool): Flag to determine if NaN's should be compared as equal.\nReturns:\n- y (array_like): An array indicating where elements of 'a' and 'b' are approximately equal within the specified tolerances. Returns a single boolean value if both 'a' and 'b' are scalars."
  },
  "numpy.iscomplex": {
    "new_func": "has_imaginary_part",
    "description": "Check if elements in an array have a non-zero imaginary component.\nParameters:\n- x (array_like): Input array to check for complex numbers.\nReturns:\n- out (array of bools): Array indicating which elements have a non-zero imaginary part."
  },
  "numpy.iscomplexobj": {
    "new_func": "check_complex_type",
    "description": "Determine if the input is of a complex data type or contains complex numbers.\nParameters:\n- x (any): The input of any type or shape to check.\nReturns:\n- iscomplexobj (bool): True if the input is of a complex type or contains at least one element with a complex type."
  },
  "numpy.polyfit": {
    "new_func": "coefficients_regression",
    "description": "Calculates the coefficients that best fit a polynomial of a specified degree to a set of data points, using the method of least squares. This method minimizes the sum of the squares of the residuals, the differences between the observed and calculated values.\nParameters:\n- x (array_like, shape (M,)): x-coordinates of the M sample points.\n- y (array_like, shape (M,) or (M, K)): y-coordinates of the sample points.\n- deg (int): Degree of the fitting polynomial.\n- rcond (float, optional): Cut-off ratio for small singular values.\n- full (bool, optional): Determines the nature of the return value. When False, only the coefficients are returned. When True, diagnostic information is also returned.\n- w (array_like, shape (M,), optional): Weights for each point.\n- cov (bool or str, optional): If true, the covariance matrix of the polynomial coefficient estimates is returned.\nReturns:\n- coefficients (array, shape (deg + 1,) or (deg + 1, K)): Polynomial coefficients, highest power first."
  },
  "numpy.polyint": {
    "new_func": "polynomial_antiderivative",
    "description": "Calculates the antiderivative of a given polynomial, increasing its degree by a specified amount and adding integration constants.\nParameters:\n- p (array_like or poly1d): Polynomial coefficients to integrate.\n- m (int, optional): Order of the antiderivative.\n- k (list of m scalars or scalar, optional): Integration constants.\nReturns:\n- antiderivative (array or poly1d): The polynomial antiderivative."
  },
  "numpy.polymul": {
    "new_func": "polynomial_product",
    "description": "Computes the product of two input polynomials, resulting in a new polynomial whose degree is the sum of the degrees of the input polynomials.\nParameters:\n- a1 (array_like or poly1d): First input polynomial.\n- a2 (array_like or poly1d): Second input polynomial.\nReturns:\n- product (array or poly1d): Resultant polynomial from the product of the input polynomials."
  },
  "numpy.polyadd": {
    "new_func": "polynomial_summation",
    "description": "Determines the sum of two input polynomials, resulting in a new polynomial that combines the terms of both.\nParameters:\n- a1 (array_like or poly1d): First polynomial to add.\n- a2 (array_like or poly1d): Second polynomial to add.\nReturns:\n- sum (array or poly1d): Polynomial resulting from the sum of the input polynomials."
  },
  "numpy.polysub": {
    "new_func": "polynomial_difference",
    "description": "Calculates the difference between two input polynomials, effectively subtracting one from the other.\nParameters:\n- a1 (array_like or poly1d): Polynomial from which to subtract.\n- a2 (array_like or poly1d): Polynomial to subtract.\nReturns:\n- difference (array or poly1d): Resultant polynomial after subtraction."
  },
  "numpy.positive": {
    "new_func": "elementary_identity",
    "description": "Returns an array with the identity operation applied to each element.\nParameters:\n- input_array: array_like or scalar, Input data.\nReturns:\n- result_array: array or scalar, Resultant array with the identity operation applied: y = +input_array."
  },
  "numpy.polyval": {
    "new_func": "polynomial_evaluation",
    "description": "Calculates the values of a specified polynomial at given points.\nParameters:\n- coefficients: array_like or poly1d object, Coefficients of the polynomial which are given in decreasing order of power.\n- points: array_like or poly1d object, Points at which to evaluate the polynomial.\nReturns:\n- evaluated_values: array or poly1d, Evaluated polynomial at the specified points. If the points argument is a polynomial, the result is the composition of the two polynomials."
  },
  "numpy.pow": {
    "new_func": "elementwise_exponentiation",
    "description": "Computes the exponentiation of corresponding elements in two arrays.\nParameters:\n- base_array: array_like, The array of bases.\n- exponent_array: array_like, The array of exponents.\n- output_array: array, optional, A location into which the result is stored.\n- condition: array_like, optional, A boolean array that is broadcasted to determine where the operation is applied.\n- kwargs: additional keyword arguments.\nReturns:\n- result_array: array, The result of raising each element in the base array to the corresponding element in the exponent array."
  },
  "numpy.printoptions": {
    "new_func": "display_format_context",
    "description": "A context manager for temporarily setting array display options.\nParameters:\n- args: Variable length argument list for display options.\n- kwargs: Arbitrary keyword arguments for display options.\nReturns:\n- context: The current display options before entering the block."
  },
  "numpy.power": {
    "new_func": "elementwise_potency",
    "description": "Raises elements of the first array to powers specified in the second array, on an element-by-element basis.\nParameters:\n- base_elements: array_like, The base numbers.\n- power_elements: array_like, The exponent numbers.\n- result_container: array, optional, Container for the results.\n- condition: array_like, optional, Boolean mask where operations are performed.\n- additional_params: additional keyword arguments.\nReturns:\n- output_values: array, The bases raised to the respective powers, matching the broadcasted shape."
  },
  "numpy.fft.irfftn": {
    "new_func": "multidimensional_real_inverse_transform",
    "description": "Performs the inverse multi-dimensional discrete Fourier transformation for real-valued input using a fast algorithm. Restores the original M-dimensional spatial domain signal from its frequency domain representation. The output is the same size as the input signal and is computed over a specified number of axes.\nParameters:\n- array_like: Input array with real input frequency components.\n- sequence of ints (optional): Dimensions of the output signal. If not provided, defaults to the input size.\n- sequence of ints (optional): Axes over which to perform the transformation. Defaults to the last len(s) axes.\n- {'backward', 'ortho', 'forward'} (optional): Normalization mode, defaulting to 'backward'.\n- array (optional): Output array to place the result.\nReturns:\n- array: The spatial domain signal corresponding to the frequency domain input."
  },
  "numpy.fft.irfft": {
    "new_func": "one_dimensional_real_inverse_transform",
    "description": "Calculates the one-dimensional inverse discrete Fourier transformation for a real-valued frequency domain signal. It restores the original signal from its frequency representation, assuming the input is the positive frequency terms of a Hermitian-symmetric sequence.\nParameters:\n- array_like: Input array containing real frequency components.\n- int (optional): Length of the output signal. If not provided, inferred from input size.\n- int (optional): Axis to perform the transformation on. Default is the last axis.\n- {'backward', 'ortho', 'forward'} (optional): Normalization mode, defaulting to 'backward'.\n- array (optional): Output array to store the result.\nReturns:\n- array: The reconstructed one-dimensional time domain signal from the input."
  },
  "numpy.fft.irfft2": {
    "new_func": "two_dimensional_real_inverse_transform",
    "description": "Executes an inverse two-dimensional discrete Fourier transformation for real-valued input, transforming frequency domain data back into the spatial domain. It is specialized for two-dimensional signals and uses a fast computation algorithm.\nParameters:\n- array_like: Input array with real frequency domain data.\n- sequence of ints (optional): Desired shape for the two-dimensional output.\n- sequence of ints (optional): Axes over which to compute the inverse transform. Defaults to the last two axes.\n- {'backward', 'ortho', 'forward'} (optional): Normalization mode, defaulting to 'backward'.\n- array (optional): Output array to place the result.\nReturns:\n- array: The spatial domain signal corresponding to the two-dimensional frequency domain input."
  },
  "numpy.fft.rfft": {
    "new_func": "one_dimensional_real_frequency_transform",
    "description": "Computes the one-dimensional discrete Fourier transformation for real-valued input, resulting in a compact frequency domain representation. The output contains only the non-negative frequency terms due to Hermitian symmetry, with the algorithm optimized for speed.\nParameters:\n- array_like: Input array with real values.\n- int (optional): Number of points for the transformation axis in the output. Defaults to the input length along the specified axis.\n- int (optional): Axis to perform the transformation on. Defaults to the last axis.\n- {'backward', 'ortho', 'forward'} (optional): Normalization mode, defaulting to 'backward'.\n- complex array (optional): Output array to store the result.\nReturns:\n- complex array: The frequency domain representation of the input signal, excluding negative frequency terms."
  },
  "numpy.fft.rfft2": {
    "new_func": "two_dimensional_real_frequency_transform",
    "description": "Performs the two-dimensional discrete Fourier transformation on real-valued input, providing a frequency domain representation that is optimized for 2D data. The output includes only non-negative frequency components due to the inherent symmetry in the transformation of real inputs.\nParameters:\n- array_like: Input array assumed to be real.\n- sequence of ints (optional): Shape of the desired two-dimensional frequency domain output.\n- sequence of ints (optional): Axes which the transformation is computed over. Defaults to the last two axes.\n- {'backward', 'ortho', 'forward'} (optional): Specifies the normalization mode, with a default of 'backward'.\n- complex array (optional): Output array to store the result.\nReturns:\n- array: The frequency domain representation of the two-dimensional real-valued input signal."
  },
  "numpy.linalg.inv": {
    "new_func": "reverse_matrix",
    "description": "Calculate the multiplicative inverse of a given square matrix such that the product of the matrix and its inverse yields the identity matrix of the same dimensions. The input matrix must be square and non-singular.\nParameters:\n- matrix (..., M, M) array_like: The square matrix to invert.\nReturns:\n- inverse_matrix (..., M, M) array: The inverse of the input matrix.\nRaises:\n- LinAlgError: If the input is not square or the inversion operation is not possible."
  },
  "numpy.linalg.eigvalsh": {
    "new_func": "symmetric_eigenvalues",
    "description": "Obtain the eigenvalues for a Hermitian or symmetric matrix, without computing the eigenvectors. This is often used for matrices where the values of interest are the eigenvalues themselves.\nParameters:\n- matrix (..., M, M) array_like: The input Hermitian or symmetric matrix.\n- triangle ('L' or 'U', optional): Whether to use the lower or upper triangle of the matrix. Defaults to 'L'.\nReturns:\n- eigenvalues (..., M) array: The eigenvalues of the matrix, sorted in ascending order.\nRaises:\n- LinAlgError: If the eigenvalue computation does not converge."
  },
  "numpy.linalg.eigh": {
    "new_func": "symmetric_eigenpairs",
    "description": "Determine both eigenvalues and their corresponding eigenvectors for a Hermitian or symmetric matrix. The result includes a vector of eigenvalues and a matrix of the normalized eigenvectors for each eigenvalue.\nParameters:\n- matrix (..., M, M) array_like: The input Hermitian or symmetric matrix.\n- triangle ('L' or 'U', optional): Specifies which triangular part to use. Defaults to 'L'.\nReturns:\n- eigenpairs: A namedtuple with attributes 'eigenvalues' and 'eigenvectors'.\n- eigenvalues (..., M) array: The eigenvalues in ascending order.\n- eigenvectors (..., M, M) array or matrix: Normalized eigenvectors corresponding to the eigenvalues.\nRaises:\n- LinAlgError: If the eigenvalue computation does not converge."
  },
  "numpy.linalg.matmul": {
    "new_func": "matrix_product",
    "description": "Calculate the matrix product of two arrays. It behaves similar to the dot product for two-dimensional arrays but also supports broadcasting and matrix chain multiplication.\nParameters:\n- first_array array_like: The first array to multiply.\n- second_array array_like: The second array to multiply.\nReturns:\n- product array: The resultant matrix product of the two inputs.\nRaises:\n- ValueError: If the dimensions are not aligned for matrix multiplication."
  },
  "numpy.linalg.lstsq": {
    "new_func": "minimize_residuals",
    "description": "Solve the least-squares linear equation, finding the vector that minimizes the 2-norm of the residuals. The equation to solve is of the form ax = b, which may be under-, well-, or over-determined.\nParameters:\n- coefficients (M, N) array_like: The 'coefficient' matrix.\n- dependent_vars {(M,), (M, K)} array_like: 'Dependent variable' values. If two-dimensional, a solution is found for each column.\n- rcond float, optional: Cut-off ratio for small singular values. Defaults to machine precision times max(M, N).\nReturns:\n- solution {(N,), (N, K)} array: The least-squares solution.\n- residuals {(1,), (K,), (0,)} array: Sums of squared residuals.\n- rank int: The rank of the coefficient matrix.\n- singular_vals (min(M, N),) array: Singular values of the coefficient matrix.\nRaises:\n- LinAlgError: If the computation does not converge."
  },
  "numpy.linalg.matrix_norm": {
    "new_func": "matrix_magnitude",
    "description": "Calculates the magnitude of a matrix or a batch of matrices. Accepts an input array with dimensions indicating a series of matrices to be processed. The magnitude is determined using a specified order. Optionally maintains the dimensionality of the result.\nParameters:\n- input_array: array_like, Input array with shape indicating MxN matrices.\n- maintain_dims: bool, optional, Preserves the reduced dimensions if True. Default is False.\n- order: Various norm orders, optional, Specifies the order of the magnitude calculation.\nReturns:\n- magnitude: array_like, The magnitude of the input matrices."
  },
  "numpy.linalg.matrix_rank": {
    "new_func": "determine_dimensionality",
    "description": "Calculates the dimensionality or effective rank of a matrix or a set of matrices using Singular Value Decomposition. The rank is based on the number of singular values greater than a specified threshold. Works with a stack of matrices as well.\nParameters:\n- input_matrix: array_like, Input vector or stack of matrices.\n- tolerance: array_like, float, optional, Threshold for considering singular values as zero. If None, automatically determined.\n- hermitian: bool, optional, If True, the input is treated as Hermitian, allowing a more efficient computation. Default is False.\n- relative_tolerance: array_like, float, optional, Relative tolerance component for threshold. Either tolerance or relative_tolerance can be set.\nReturns:\n- rank: array_like, The effective rank of the input matrix or matrices."
  },
  "numpy.linalg.matrix_power": {
    "new_func": "matrix_exponentiation",
    "description": "Raises a square matrix to an integer power. The computation is performed through repeated squarings and multiplications. Identity matrix is returned for zero power. For negative powers, the inverse is computed and raised to the absolute power.\nParameters:\n- base_matrix: array_like, The matrix to be exponentiated, square shape required.\n- exponent: int, The power to raise the matrix to, can be positive, negative, or zero.\nReturns:\n- result_matrix: array_like, The exponentiated matrix, same type and shape as the base matrix.\nRaises:\n- LinAlgError: If the input matrix is not square or (for negative powers) cannot be inverted."
  },
  "numpy.linalg.norm": {
    "new_func": "calculate_magnitude",
    "description": "Computes the magnitude of a matrix or vector. The function can return a wide range of magnitudes depending on the specified parameters, including various matrix norms and an infinite number of vector norms.\nParameters:\n- input_array: array_like, The input array for which the norm is calculated.\n- order: optional, The magnitude order to be calculated.\n- axis: optional, Specifies the axis or axes along which to compute the norms.\n- maintain_dims: bool, optional, Whether to keep reduced dimensions.\nReturns:\n- magnitude: float or array, The computed magnitude of the input array."
  },
  "numpy.linalg.matrix_transpose": {
    "new_func": "matrix_reorientation",
    "description": "Reorients a matrix or a series of matrices by switching its rows and columns.\nParameters:\n- input_array: array_like, Input array with the last two dimensions forming matrices.\nReturns:\n- transposed: array, An array with the transposed matrices for each input matrix, dimensions switched."
  },
  "numpy.testing.assert_no_gc_cycles": {
    "new_func": "verify_absence_of_recirculation",
    "description": "Validate that a specified callable does not create any reference loops. This can be utilized directly by providing a callable and any necessary arguments, or used as a context manager to evaluate a block of code for the creation of reference cycles.\nParameters:\n- callable: function, The function to evaluate.\n- *args: variadic arguments, Arguments to pass to the callable.\n- **kwargs: variadic keyword arguments, Keyword arguments to pass to the callable.\nReturns:\n- None: No return value, as the function's output is intentionally ignored to detect all cycles."
  },
  "numpy.testing.assert_string_equal": {
    "new_func": "affirm_textual_similarity",
    "description": "Verify that two text snippets are identical. If the snippets match, the function completes silently. Otherwise, it raises an error and presents the differences.\nParameters:\n- actual: string, The observed text for comparison.\n- desired: string, The anticipated text for comparison.\nExamples:\n- affirm_textual_similarity('hello', 'hello') passes without an issue.\n- affirm_textual_similarity('hello', 'hello world') raises an AssertionError and displays the discrepancy."
  },
  "numpy.testing.assert_raises": {
    "new_func": "expect_exception_throw",
    "description": "Ensure that a specific exception is raised when a provided block of code is executed. This can be done by directly passing a callable and its arguments or by using it as a context manager to encapsulate the code expected to raise the exception.\nParameters:\n- exception_class: class, The type of exception anticipated.\n- callable: function, The function to be invoked.\n- *args: variadic arguments, Arguments for the callable.\n- **kwargs: variadic keyword arguments, Keyword arguments for the callable.\nExamples:\n- expect_exception_throw(ZeroDivisionError, lambda x: 1/x, 0) checks that dividing by zero raises the correct error."
  },
  "numpy.testing.assert_raises_regex": {
    "new_func": "anticipate_exception_with_pattern",
    "description": "Confirm that an exception of a certain type is thrown, with a message that matches a specific regular expression pattern. This verification can be performed by providing a callable and its arguments or used as a context manager to assess a piece of code.\nParameters:\n- exception_class: class, The class of the expected exception.\n- expected_regexp: string, The regular expression the exception message should match.\n- callable: function, The function to be tested.\n- *args: variadic arguments, Arguments to pass to the callable.\n- **kwargs: variadic keyword arguments, Keyword arguments to pass to the callable."
  },
  "numpy.testing.assert_warns": {
    "new_func": "validate_caution_emission",
    "description": "Check that a function emits a particular warning when executed. The warning expected should be of the type provided, and the function should be called with the given arguments and keyword arguments. This function can also act as a context manager to assess whether a warning is emitted during the execution of a block of code.\nParameters:\n- warning_class: class, The warning type the function is expected to emit.\n- callable: function, optional, The function to be tested.\n- *args: variadic arguments, Arguments for the function.\n- **kwargs: variadic keyword arguments, Keyword arguments for the function.\nReturns:\n- The return value from the function.\nExamples:\n- Using validate_caution_emission as a context manager to assert that a deprecation warning is emitted.\n- Call the function directly with the warning class, function reference, and arguments to check for warnings."
  }
}
